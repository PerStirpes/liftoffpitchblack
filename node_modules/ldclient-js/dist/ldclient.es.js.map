{"version":3,"file":"ldclient.es.js","sources":["../src/errors.js","../node_modules/base64-js/index.js","../node_modules/fast-deep-equal/index.js","../src/utils.js","../src/EventSender.js","../src/EventSummarizer.js","../src/messages.js","../src/UserFilter.js","../src/EventProcessor.js","../src/EventEmitter.js","../node_modules/escape-string-regexp/index.js","../src/GoalTracker.js","../src/Store.js","../src/Stream.js","../src/Requestor.js","../src/Identity.js","../src/index.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  var arrA = Array.isArray(a)\n    , arrB = Array.isArray(b)\n    , i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n    for (i = 0; i < a.length; i++)\n      if (!equal(a[i], b[i])) return false;\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    var keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    if (dateA != dateB) return false;\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    if (regexpA != regexpB) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if(!equal(a[keys[i]], b[keys[i]])) return false;\n\n    return true;\n  }\n\n  return false;\n};\n","import * as base64 from 'base64-js';\nimport fastDeepEqual from 'fast-deep-equal';\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (flags.hasOwnProperty(key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (flagsState.hasOwnProperty(key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString() {\n  return 'JSClient/' + VERSION;\n}\n\nexport function addLDHeaders(xhr) {\n  xhr.setRequestHeader('X-LaunchDarkly-User-Agent', getLDUserAgentString());\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(eventsUrl, environmentId, forceHasCors, imageCreator) {\n  let hasCors;\n  const postUrl = eventsUrl + '/events/bulk/' + environmentId;\n  const imageUrl = eventsUrl + '/a/' + environmentId + '.gif';\n  const sender = {};\n\n  function loadUrlUsingImage(src, onDone) {\n    const img = new window.Image();\n    if (onDone) {\n      img.addEventListener('load', onDone);\n    }\n    img.src = src;\n  }\n\n  function getResponseInfo(xhr) {\n    const ret = { status: xhr.status };\n    const dateStr = xhr.getResponseHeader('Date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  function sendChunk(events, usePost, sync) {\n    const createImage = imageCreator || loadUrlUsingImage;\n    const jsonBody = JSON.stringify(events);\n    const send = onDone => {\n      function createRequest(canRetry) {\n        const xhr = new window.XMLHttpRequest();\n        xhr.open('POST', postUrl, !sync);\n        utils.addLDHeaders(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.setRequestHeader('X-LaunchDarkly-Event-Schema', '3');\n        if (!sync) {\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 400 && errors.isHttpErrorRecoverable(xhr.status) && canRetry) {\n              createRequest(false).send(jsonBody);\n            } else {\n              onDone(getResponseInfo(xhr));\n            }\n          });\n          if (canRetry) {\n            xhr.addEventListener('error', () => {\n              createRequest(false).send(jsonBody);\n            });\n          }\n        }\n        return xhr;\n      }\n      if (usePost) {\n        createRequest(true).send(jsonBody);\n      } else {\n        const src = imageUrl + '?d=' + utils.base64URLEncode(jsonBody);\n        createImage(src, sync ? null : onDone);\n      }\n    };\n\n    if (sync) {\n      send();\n    } else {\n      return new Promise(resolve => {\n        send(resolve);\n      });\n    }\n  }\n\n  sender.sendEvents = function(events, sync) {\n    // Detect browser support for CORS (can be overridden by tests)\n    if (hasCors === undefined) {\n      if (forceHasCors === undefined) {\n        hasCors = 'withCredentials' in new window.XMLHttpRequest();\n      } else {\n        hasCors = forceHasCors;\n      }\n    }\n\n    const finalSync = sync === undefined ? false : sync;\n    let chunks;\n    if (hasCors) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - eventsUrl.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sendChunk(chunks[i], hasCors, finalSync));\n    }\n    return sync ? Promise.resolve() : Promise.all(results);\n  };\n\n  return sender;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","import * as errors from './errors';\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'environment not found.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + (err.message || err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  return '[LaunchDarkly] \"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate =\n    config.allAttributesPrivate !== undefined ? config.allAttributesPrivate : config.all_attributes_private;\n  const privateAttributeNames =\n    (config.privateAttributeNames !== undefined ? config.privateAttributeNames : config.private_attribute_names) || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  if (config.all_attributes_private !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('all_attributes_private', 'allAttributesPrivate'));\n  }\n  if (config.private_attribute_names !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('private_attribute_names', 'privateAttributeNames'));\n  }\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(eventsUrl, environmentId, options = {}, emitter = null, sender = null) {\n  const processor = {};\n  const eventSender = sender || EventSender(eventsUrl, environmentId);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = !!options.inlineUsersInEvents;\n  let queue = [];\n  let flushInterval;\n  let samplingInterval;\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let flushTimer;\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  if (options.samplingInterval !== undefined && (isNaN(options.samplingInterval) || options.samplingInterval < 0)) {\n    samplingInterval = 0;\n    reportArgumentError('Invalid sampling interval configured. Sampling interval must be an integer >= 0.');\n  } else {\n    samplingInterval = options.samplingInterval || 0;\n  }\n\n  if (options.flushInterval !== undefined && (isNaN(options.flushInterval) || options.flushInterval < 2000)) {\n    flushInterval = 2000;\n    reportArgumentError('Invalid flush interval configured. Must be an integer >= 2000 (milliseconds).');\n  } else {\n    flushInterval = options.flushInterval || 2000;\n  }\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      queue.push(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      queue.push(debugEvent);\n    }\n  };\n\n  processor.flush = function(sync) {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    return eventSender.sendEvents(eventsToSend, sync).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventEmitter() {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      events[event][i].handler.apply(events[event][i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      console.error(error.message);\n    }\n  };\n  return emitter;\n}\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","import escapeStringRegexp from 'escape-string-regexp';\n\nfunction doesUrlMatch(matcher, href, search, hash) {\n  const canonicalUrl = href.replace(search, '').replace(hash, '');\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], window.location.href, window.location.search, window.location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function(event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function() {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n","import * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function Store(environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  store.loadFlags = function() {\n    const key = getFlagsKey();\n    let dataStr, data;\n    try {\n      dataStr = window.localStorage.getItem(key);\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n      return null;\n    }\n    try {\n      data = JSON.parse(dataStr);\n    } catch (ex) {\n      store.clearFlags();\n      return null;\n    }\n    if (data) {\n      const schema = data.$schema;\n      if (schema === undefined || schema < 1) {\n        data = utils.transformValuesToVersionedValues(data);\n      }\n    }\n    return data;\n  };\n\n  store.saveFlags = function(flags) {\n    const key = getFlagsKey();\n    const data = utils.extend({}, flags, { $schema: 1 });\n    try {\n      window.localStorage.setItem(key, JSON.stringify(data));\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n    }\n  };\n\n  store.clearFlags = function() {\n    const key = getFlagsKey();\n    try {\n      window.localStorage.removeItem(key);\n    } catch (ex) {}\n  };\n\n  return store;\n}\n","import { base64URLEncode } from './utils';\n\nexport default function Stream(baseUrl, environment, hash, config) {\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment + '/';\n  const useReport = (config && config.useReport) || false;\n  const withReasons = (config && config.evaluationReasons) || false;\n  const streamReconnectDelay = (config && config.streamReconnectDelay) || 1000;\n  const timeoutMillis = 300000; // 5 minutes (same as other SDKs) - note, this only has an effect on polyfills\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let user = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHandlers) {\n    user = newUser;\n    handlers = newHandlers;\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return es && (es.readyState === window.EventSource.OPEN || es.readyState === window.EventSource.CONNECTING);\n  };\n\n  function reconnect() {\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    let url;\n    let query = '';\n    if (typeof window.EventSource !== 'undefined') {\n      if (useReport) {\n        // we don't yet have an EventSource implementation that supports REPORT, so\n        // fall back to the old ping-based stream\n        url = baseUrl + '/ping/' + environment;\n      } else {\n        url = evalUrlPrefix + base64URLEncode(JSON.stringify(user));\n        if (hash !== null && hash !== undefined) {\n          query = 'h=' + hash;\n        }\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n\n      // The standard EventSource constructor doesn't take any options, just a URL. However, some\n      // EventSource polyfills allow us to specify a timeout interval, and in some cases they will\n      // default to a too-short timeout if we don't specify one. So, here, we are setting the\n      // timeout properties that are used by several popular polyfills.\n      const options = {\n        heartbeatTimeout: timeoutMillis, // used by \"event-source-polyfill\" package\n        silentTimeout: timeoutMillis, // used by \"eventsource-polyfill\" package\n      };\n\n      es = new window.EventSource(url, options);\n      for (const key in handlers) {\n        if (handlers.hasOwnProperty(key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = reconnect;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      es.close();\n      es = null;\n    }\n  }\n\n  return stream;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst json = 'application/json';\n\nfunction fetchJSON(endpoint, body, callback, sendLDHeaders) {\n  const xhr = new window.XMLHttpRequest();\n  let data = undefined;\n\n  xhr.addEventListener('load', () => {\n    if (\n      xhr.status === 200 &&\n      xhr.getResponseHeader('Content-type') &&\n      xhr.getResponseHeader('Content-Type').lastIndexOf(json) === 0\n    ) {\n      callback(null, JSON.parse(xhr.responseText));\n    } else {\n      callback(getResponseError(xhr));\n    }\n  });\n\n  xhr.addEventListener('error', () => {\n    callback(getResponseError(xhr));\n  });\n\n  if (body) {\n    xhr.open('REPORT', endpoint);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    data = JSON.stringify(body);\n  } else {\n    xhr.open('GET', endpoint);\n  }\n\n  if (sendLDHeaders) {\n    utils.addLDHeaders(xhr);\n  }\n\n  xhr.send(data);\n\n  return xhr;\n}\n\nfunction getResponseError(xhr) {\n  if (xhr.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return xhr.statusText;\n  }\n}\n\nexport default function Requestor(baseUrl, environment, useReport, withReasons, sendLDHeaders) {\n  let flagSettingsRequest;\n  let lastFlagSettingsCallback;\n\n  const requestor = {};\n\n  requestor.fetchFlagSettings = function(user, hash, callback) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n    let cb;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = user;\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n\n    const wrappedCallback = (function(currentCallback) {\n      return function(error, result) {\n        currentCallback(error, result);\n        flagSettingsRequest = null;\n        lastFlagSettingsCallback = null;\n      };\n    })(callback);\n\n    if (flagSettingsRequest) {\n      flagSettingsRequest.abort();\n      cb = (function(prevCallback) {\n        return function() {\n          prevCallback && prevCallback.apply(null, arguments);\n          wrappedCallback.apply(null, arguments);\n        };\n      })(lastFlagSettingsCallback);\n    } else {\n      cb = wrappedCallback;\n    }\n\n    lastFlagSettingsCallback = cb;\n    flagSettingsRequest = fetchJSON(endpoint, body, cb, sendLDHeaders);\n  };\n\n  requestor.fetchGoals = function(callback) {\n    const endpoint = [baseUrl, '/sdk/goals/', environment].join('');\n    fetchJSON(endpoint, null, callback, sendLDHeaders);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nfunction sanitizeUser(u) {\n  const sane = utils.clone(u);\n  if (sane.key) {\n    sane.key = sane.key.toString();\n  }\n  return sane;\n}\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = sanitizeUser(u);\n    onChange(utils.clone(user));\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport GoalTracker from './GoalTracker';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport * as utils from './utils';\nimport * as messages from './messages';\nimport * as errors from './errors';\n\nconst readyEvent = 'ready';\nconst successEvent = 'initialized';\nconst failedEvent = 'failed';\nconst changeEvent = 'change';\nconst goalsEvent = 'goalsReady';\nconst locationWatcherInterval = 300;\n\nexport function initialize(env, user, options = {}) {\n  const baseUrl = options.baseUrl || 'https://app.launchdarkly.com';\n  const eventsUrl = options.eventsUrl || 'https://events.launchdarkly.com';\n  const streamUrl = options.streamUrl || 'https://clientstream.launchdarkly.com';\n  const hash = options.hash;\n  const sendEvents = optionWithDefault('sendEvents', true);\n  const sendLDHeaders = optionWithDefault('sendLDHeaders', true);\n  const allowFrequentDuplicateEvents = !!options.allowFrequentDuplicateEvents;\n  const sendEventsOnlyForVariation = !!options.sendEventsOnlyForVariation;\n  const fetchGoals = typeof options.fetchGoals === 'undefined' ? true : options.fetchGoals;\n  const environment = env;\n  const emitter = EventEmitter();\n  const stream = Stream(streamUrl, environment, hash, options);\n  const events = options.eventProcessor || EventProcessor(eventsUrl, environment, options, emitter);\n  const requestor = Requestor(baseUrl, environment, options.useReport, options.evaluationReasons, sendLDHeaders);\n  const seenRequests = {};\n  let flags = typeof options.bootstrap === 'object' ? readFlagsFromBootstrap(options.bootstrap) : {};\n  let goalTracker;\n  let useLocalStorage;\n  let goals;\n  let streamActive;\n  let streamForcedState;\n  let subscribedToChangeEvents;\n  let firstEvent = true;\n\n  function optionWithDefault(name, defaultVal) {\n    return typeof options[name] === 'undefined' ? defaultVal : options[name];\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      console.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      console.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !doNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!event.user) {\n      if (firstEvent) {\n        if (console && console.warn) {\n          console.warn(\n            'Be sure to call `identify` in the LaunchDarkly client: http://docs.launchdarkly.com/docs/running-an-ab-test#include-the-client-side-snippet'\n          );\n        }\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  const ident = Identity(user, sendIdentifyEvent);\n  const store = Store(environment, hash, ident);\n\n  function sendFlagEvent(key, detail, defaultValue) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n      reason: detail ? detail.reason : null,\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      user: ident.getUser(),\n      creationDate: new Date().getTime(),\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return enqueueEvent(event);\n  }\n\n  function identify(user, hash, onDone) {\n    if (useLocalStorage) {\n      store.clearFlags();\n    }\n    return utils.wrapPromiseCallback(\n      new Promise((resolve, reject) => {\n        if (!user || user.key === null || user.key === undefined) {\n          const err = new errors.LDInvalidUserError(user ? messages.invalidUser() : messages.userNotSpecified());\n          emitter.maybeReportError(err);\n          reject(err);\n        } else {\n          ident.setUser(user);\n          requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n            if (err) {\n              emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n              return reject(err);\n            }\n            if (settings) {\n              updateSettings(settings);\n            }\n            resolve(utils.transformVersionedValuesToValues(settings));\n            if (streamActive) {\n              connectStream();\n            }\n          });\n        }\n      }),\n      onDone\n    );\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(\n      new Promise(resolve => (sendEvents ? resolve(events.flush()) : resolve()), onDone)\n    );\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent) {\n    let detail;\n\n    if (flags && flags.hasOwnProperty(key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function doNotTrack() {\n    let flag;\n    if (window.navigator && window.navigator.doNotTrack !== undefined) {\n      flag = window.navigator.doNotTrack; // FF, Chrome\n    } else if (window.navigator && window.navigator.msDoNotTrack !== undefined) {\n      flag = window.navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === '1' || flag === 'yes';\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key)) {\n        results[key] = variationDetailInternal(key, null, !sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function customEventExists(key) {\n    if (!goals || goals.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < goals.length; i++) {\n      if (goals[i].kind === 'custom' && goals[i].key === key) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function track(key, data) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    // Validate key if we have goals\n    if (!!goals && !customEventExists(key)) {\n      console.warn(messages.unknownCustomEventKey(key));\n    }\n\n    enqueueEvent({\n      kind: 'custom',\n      key: key,\n      data: data,\n      user: ident.getUser(),\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), {\n      ping: function() {\n        requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n          if (err) {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          }\n          updateSettings(settings);\n        });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        updateSettings(data);\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          postProcessSettingsUpdate(mods);\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          postProcessSettingsUpdate(mods);\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  function updateSettings(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (newFlags.hasOwnProperty(key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = newFlags;\n    postProcessSettingsUpdate(changes);\n  }\n\n  function postProcessSettingsUpdate(changes) {\n    const keys = Object.keys(changes);\n\n    if (useLocalStorage) {\n      store.saveFlags(flags);\n    }\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n\n      if (!sendEventsOnlyForVariation) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (!streamActive && streamForcedState === undefined) {\n        connectStream();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n      if (shouldBeStreaming && !streamActive) {\n        connectStream();\n      } else if (!shouldBeStreaming && streamActive) {\n        disconnectStream();\n      }\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  function handleMessage(event) {\n    if (event.origin !== baseUrl) {\n      return;\n    }\n    if (event.data.type === 'SYN') {\n      window.editorClientBaseUrl = baseUrl;\n      const editorTag = document.createElement('script');\n      editorTag.type = 'text/javascript';\n      editorTag.async = true;\n      editorTag.src = baseUrl + event.data.editorClientUrl;\n      const s = document.getElementsByTagName('script')[0];\n      s.parentNode.insertBefore(editorTag, s);\n    }\n  }\n\n  if (!env) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    });\n  }\n\n  if (!user) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    });\n  } else if (!user.key) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.invalidUser()));\n    });\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    utils.onNextTick(signalSuccessfulInit);\n  } else if (\n    typeof options.bootstrap === 'string' &&\n    options.bootstrap.toUpperCase() === 'LOCALSTORAGE' &&\n    !!window.localStorage\n  ) {\n    useLocalStorage = true;\n\n    flags = store.loadFlags();\n\n    if (flags === null) {\n      flags = {};\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n          signalFailedInit(initErr);\n        } else {\n          if (settings) {\n            updateSettings(settings); // this includes saving to local storage and sending change events\n          } else {\n            flags = {};\n          }\n          signalSuccessfulInit();\n        }\n      });\n    } else {\n      // We're reading the flags from local storage. Signal that we're ready immediately, but also\n      // start a request in the background to get newer flags. When we receive those, we will update\n      // localStorage, and will also send change events if the values have changed.\n      utils.onNextTick(signalSuccessfulInit);\n\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n        }\n        if (settings) {\n          updateSettings(settings); // this includes saving to local storage and sending change events\n        }\n      });\n    }\n  } else {\n    requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n      if (err) {\n        flags = {};\n        const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n        signalFailedInit(initErr);\n      } else {\n        flags = settings || {};\n        signalSuccessfulInit();\n      }\n    });\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = window.location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = window.location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (!!(window.history && window.history.pushState)) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  if (fetchGoals) {\n    requestor.fetchGoals((err, g) => {\n      if (err) {\n        emitter.maybeReportError(\n          new errors.LDUnexpectedResponseError('Error fetching goals: ' + err.message ? err.message : err)\n        );\n      }\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      emitter.emit(goalsEvent);\n    });\n  }\n\n  function signalSuccessfulInit() {\n    if (options.streaming !== undefined) {\n      setStreaming(options.streaming);\n    }\n    emitter.emit(readyEvent);\n    emitter.emit(successEvent); // allows initPromise to distinguish between success and failure\n  }\n\n  function signalFailedInit(err) {\n    emitter.maybeReportError(err);\n    emitter.emit(failedEvent, err);\n    emitter.emit(readyEvent); // for backward compatibility, this event happens even on failure\n  }\n\n  function start() {\n    if (sendEvents) {\n      events.start();\n    }\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', start);\n  } else {\n    start();\n  }\n\n  window.addEventListener('beforeunload', () => {\n    if (sendEvents) {\n      events.stop();\n      events.flush(true);\n    }\n  });\n\n  window.addEventListener('message', handleMessage);\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = emitter.on(readyEvent, () => {\n      emitter.off(readyEvent, onReady);\n      resolve();\n    });\n  });\n\n  const goalsPromise = new Promise(resolve => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n\n  const initPromise = new Promise((resolve, reject) => {\n    const onSuccess = emitter.on(successEvent, () => {\n      emitter.off(successEvent, onSuccess);\n      resolve();\n    });\n    const onFailure = emitter.on(failedEvent, err => {\n      emitter.off(failedEvent, onFailure);\n      reject(err);\n    });\n  });\n\n  const client = {\n    waitForInitialization: () => initPromise,\n    waitUntilReady: () => readyPromise,\n    waitUntilGoalsReady: () => goalsPromise,\n    identify: identify,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n  };\n\n  return client;\n}\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(messages.deprecated('default export', 'named LDClient export'));\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n"],"names":["createCustomError","name","CustomError","message","code","captureStackTrace","Error","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","fromByteArray","lookup","revLookup","i","len","length","charCodeAt","tripletToBase64","num","encodeChunk","uint8","start","end","tmp","output","push","join","extraBytes","parts","len2","equal","a","b","arrA","Array","isArray","arrB","keys","Object","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","hasOwnProperty","call","btoa","s","escaped","unescape","encodeURIComponent","base64","stringToBytes","base64URLEncode","replace","clone","obj","JSON","parse","stringify","deepEquals","fastDeepEqual","onNextTick","cb","wrapPromiseCallback","promise","callback","ret","then","value","Promise","reject","error","undefined","transformValuesToVersionedValues","flags","key","version","transformVersionedValuesToValues","flagsState","chunkUserEventsForUrl","maxLength","events","allEvents","slice","allChunks","remainingSpace","chunk","event","shift","unshift","getLDUserAgentString","addLDHeaders","xhr","setRequestHeader","extend","objects","reduce","acc","MAX_URL_LENGTH","EventSender","eventsUrl","environmentId","forceHasCors","imageCreator","hasCors","postUrl","imageUrl","sender","loadUrlUsingImage","src","onDone","img","window","Image","addEventListener","sendChunk","usePost","sync","createImage","jsonBody","send","createRequest","canRetry","XMLHttpRequest","open","errors","dateStr","getResponseHeader","time","serverTime","getResponseInfo","utils","resolve","sendEvents","finalSync","chunks","results","all","EventSummarizer","es","startDate","endDate","counters","summarizeEvent","kind","counterKey","variation","counterVal","count","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","clearSummary","docLink","localStorageUnavailable","unknownCustomEventKey","environmentNotFound","environmentNotSpecified","errorFetchingFlags","err","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","UserFilter","config","filter","allAttributesPrivate","all_attributes_private","privateAttributeNames","private_attribute_names","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","console","warn","messages","filterUser","user","userPrivateAttrs","filterAttrs","props","isAttributeAllowed","indexOf","isPrivateAttr","result","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","EventProcessor","options","emitter","processor","eventSender","summarizer","userFilter","inlineUsers","inlineUsersInEvents","queue","flushInterval","samplingInterval","lastKnownPastTime","disabled","flushTimer","reportArgumentError","maybeReportError","shouldSampleEvent","Math","floor","random","isNaN","enqueue","e","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","responseInfo","setTimeout","flushTick","stop","EventEmitter","on","handler","concat","off","emit","apply","arguments","getEvents","getEventListenerCount","matchOperatorsRe","str","TypeError","doesUrlMatch","matcher","href","search","hash","canonicalUrl","regex","testUrl","escapeStringRegexp","url","substring","pattern","test","findGoalsForClick","clickGoals","matches","target","goal","selector","elements","document","querySelectorAll","j","parentNode","GoalTracker","goals","onEvent","tracker","listenerFn","urls","location","dispose","removeEventListener","Store","environment","ident","store","getFlagsKey","getUser","loadFlags","dataStr","data","localStorage","getItem","ex","clearFlags","schema","$schema","saveFlags","setItem","removeItem","Stream","baseUrl","stream","evalUrlPrefix","useReport","withReasons","evaluationReasons","streamReconnectDelay","timeoutMillis","reconnectTimeoutReference","handlers","reconnect","tryConnect","delay","openConnection","query","EventSource","onerror","closeConnection","close","connect","newUser","newHandlers","disconnect","isConnected","readyState","OPEN","CONNECTING","json","fetchJSON","endpoint","body","sendLDHeaders","lastIndexOf","responseText","getResponseError","statusText","Requestor","flagSettingsRequest","lastFlagSettingsCallback","requestor","currentCallback","prevCallback","wrappedCallback","abort","sanitizeUser","u","sane","Identity","initialUser","onChange","setUser","readyEvent","successEvent","failedEvent","changeEvent","goalsEvent","locationWatcherInterval","initialize","env","streamUrl","optionWithDefault","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","fetchGoals","eventProcessor","seenRequests","_typeof","bootstrap","metadata","forEach","readFlagsFromBootstrap","goalTracker","useLocalStorage","streamActive","streamForcedState","subscribedToChangeEvents","firstEvent","defaultVal","shouldEnqueueEvent","navigator","doNotTrack","msDoNotTrack","enqueueEvent","sendFlagEvent","detail","defaultValue","now","cacheKey","cached","variationIndex","reason","flagVersion","sendGoalEvent","variationDetailInternal","sendEvent","deleted","getFlagDetail","errorKind","connectStream","fetchFlagSettings","settings","oldFlag","mods","newFlag","newDetail","previous","current","disconnectStream","updateSettings","newFlags","changes","postProcessSettingsUpdate","changeEventParams","setStreaming","state","newState","shouldBeStreaming","isChangeEventKey","substr","refreshGoalTracker","signalSuccessfulInit","streaming","signalFailedInit","toUpperCase","g","interval","previousUrl","currentUrl","checkUrl","poll","fn","history","pushState","origin","type","editorClientBaseUrl","editorTag","createElement","async","editorClientUrl","getElementsByTagName","insertBefore","readyPromise","onReady","goalsPromise","onGoals","initPromise","onSuccess","onFailure","customEventExists","haveListeners","deprecatedInitialize"],"mappings":"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"}