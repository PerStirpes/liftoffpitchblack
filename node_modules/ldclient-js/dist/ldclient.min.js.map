{"version":3,"file":"ldclient.min.js","sources":["../src/errors.js","../node_modules/base64-js/index.js","../node_modules/fast-deep-equal/index.js","../src/utils.js","../src/EventSender.js","../src/messages.js","../src/UserFilter.js","../src/EventProcessor.js","../src/EventSummarizer.js","../src/EventEmitter.js","../node_modules/escape-string-regexp/index.js","../src/GoalTracker.js","../src/Requestor.js","../src/Identity.js","../src/index.js","../src/Stream.js","../src/Store.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","'use strict';\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  var arrA = Array.isArray(a)\n    , arrB = Array.isArray(b)\n    , i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n    for (i = 0; i < a.length; i++)\n      if (!equal(a[i], b[i])) return false;\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    var keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    if (dateA != dateB) return false;\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    if (regexpA != regexpB) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if(!equal(a[keys[i]], b[keys[i]])) return false;\n\n    return true;\n  }\n\n  return false;\n};\n","import * as base64 from 'base64-js';\nimport fastDeepEqual from 'fast-deep-equal';\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  const escaped = unescape(encodeURIComponent(s));\n  return base64.fromByteArray(stringToBytes(escaped));\n}\n\nfunction stringToBytes(s) {\n  const b = [];\n  for (let i = 0; i < s.length; i++) {\n    b.push(s.charCodeAt(i));\n  }\n  return b;\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function deepEquals(a, b) {\n  return fastDeepEqual(a, b);\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (flags.hasOwnProperty(key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (flagsState.hasOwnProperty(key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString() {\n  return 'JSClient/' + VERSION;\n}\n\nexport function addLDHeaders(xhr) {\n  xhr.setRequestHeader('X-LaunchDarkly-User-Agent', getLDUserAgentString());\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(eventsUrl, environmentId, forceHasCors, imageCreator) {\n  let hasCors;\n  const postUrl = eventsUrl + '/events/bulk/' + environmentId;\n  const imageUrl = eventsUrl + '/a/' + environmentId + '.gif';\n  const sender = {};\n\n  function loadUrlUsingImage(src, onDone) {\n    const img = new window.Image();\n    if (onDone) {\n      img.addEventListener('load', onDone);\n    }\n    img.src = src;\n  }\n\n  function getResponseInfo(xhr) {\n    const ret = { status: xhr.status };\n    const dateStr = xhr.getResponseHeader('Date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  function sendChunk(events, usePost, sync) {\n    const createImage = imageCreator || loadUrlUsingImage;\n    const jsonBody = JSON.stringify(events);\n    const send = onDone => {\n      function createRequest(canRetry) {\n        const xhr = new window.XMLHttpRequest();\n        xhr.open('POST', postUrl, !sync);\n        utils.addLDHeaders(xhr);\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.setRequestHeader('X-LaunchDarkly-Event-Schema', '3');\n        if (!sync) {\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 400 && errors.isHttpErrorRecoverable(xhr.status) && canRetry) {\n              createRequest(false).send(jsonBody);\n            } else {\n              onDone(getResponseInfo(xhr));\n            }\n          });\n          if (canRetry) {\n            xhr.addEventListener('error', () => {\n              createRequest(false).send(jsonBody);\n            });\n          }\n        }\n        return xhr;\n      }\n      if (usePost) {\n        createRequest(true).send(jsonBody);\n      } else {\n        const src = imageUrl + '?d=' + utils.base64URLEncode(jsonBody);\n        createImage(src, sync ? null : onDone);\n      }\n    };\n\n    if (sync) {\n      send();\n    } else {\n      return new Promise(resolve => {\n        send(resolve);\n      });\n    }\n  }\n\n  sender.sendEvents = function(events, sync) {\n    // Detect browser support for CORS (can be overridden by tests)\n    if (hasCors === undefined) {\n      if (forceHasCors === undefined) {\n        hasCors = 'withCredentials' in new window.XMLHttpRequest();\n      } else {\n        hasCors = forceHasCors;\n      }\n    }\n\n    const finalSync = sync === undefined ? false : sync;\n    let chunks;\n    if (hasCors) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - eventsUrl.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sendChunk(chunks[i], hasCors, finalSync));\n    }\n    return sync ? Promise.resolve() : Promise.all(results);\n  };\n\n  return sender;\n}\n","import * as errors from './errors';\n\nconst docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'environment not found.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + (err.message || err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  return '[LaunchDarkly] \"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate =\n    config.allAttributesPrivate !== undefined ? config.allAttributesPrivate : config.all_attributes_private;\n  const privateAttributeNames =\n    (config.privateAttributeNames !== undefined ? config.privateAttributeNames : config.private_attribute_names) || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  if (config.all_attributes_private !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('all_attributes_private', 'allAttributesPrivate'));\n  }\n  if (config.private_attribute_names !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('private_attribute_names', 'privateAttributeNames'));\n  }\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(eventsUrl, environmentId, options = {}, emitter = null, sender = null) {\n  const processor = {};\n  const eventSender = sender || EventSender(eventsUrl, environmentId);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = !!options.inlineUsersInEvents;\n  let queue = [];\n  let flushInterval;\n  let samplingInterval;\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let flushTimer;\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  if (options.samplingInterval !== undefined && (isNaN(options.samplingInterval) || options.samplingInterval < 0)) {\n    samplingInterval = 0;\n    reportArgumentError('Invalid sampling interval configured. Sampling interval must be an integer >= 0.');\n  } else {\n    samplingInterval = options.samplingInterval || 0;\n  }\n\n  if (options.flushInterval !== undefined && (isNaN(options.flushInterval) || options.flushInterval < 2000)) {\n    flushInterval = 2000;\n    reportArgumentError('Invalid flush interval configured. Must be an integer >= 2000 (milliseconds).');\n  } else {\n    flushInterval = options.flushInterval || 2000;\n  }\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      queue.push(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      queue.push(debugEvent);\n    }\n  };\n\n  processor.flush = function(sync) {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    return eventSender.sendEvents(eventsToSend, sync).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","export default function EventEmitter() {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      events[event][i].handler.apply(events[event][i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.getEvents = function() {\n    return Object.keys(events);\n  };\n\n  emitter.getEventListenerCount = function(event) {\n    return events[event] ? events[event].length : 0;\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      console.error(error.message);\n    }\n  };\n  return emitter;\n}\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","import escapeStringRegexp from 'escape-string-regexp';\n\nfunction doesUrlMatch(matcher, href, search, hash) {\n  const canonicalUrl = href.replace(search, '').replace(hash, '');\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], window.location.href, window.location.search, window.location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function(event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function() {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst json = 'application/json';\n\nfunction fetchJSON(endpoint, body, callback, sendLDHeaders) {\n  const xhr = new window.XMLHttpRequest();\n  let data = undefined;\n\n  xhr.addEventListener('load', () => {\n    if (\n      xhr.status === 200 &&\n      xhr.getResponseHeader('Content-type') &&\n      xhr.getResponseHeader('Content-Type').lastIndexOf(json) === 0\n    ) {\n      callback(null, JSON.parse(xhr.responseText));\n    } else {\n      callback(getResponseError(xhr));\n    }\n  });\n\n  xhr.addEventListener('error', () => {\n    callback(getResponseError(xhr));\n  });\n\n  if (body) {\n    xhr.open('REPORT', endpoint);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    data = JSON.stringify(body);\n  } else {\n    xhr.open('GET', endpoint);\n  }\n\n  if (sendLDHeaders) {\n    utils.addLDHeaders(xhr);\n  }\n\n  xhr.send(data);\n\n  return xhr;\n}\n\nfunction getResponseError(xhr) {\n  if (xhr.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return xhr.statusText;\n  }\n}\n\nexport default function Requestor(baseUrl, environment, useReport, withReasons, sendLDHeaders) {\n  let flagSettingsRequest;\n  let lastFlagSettingsCallback;\n\n  const requestor = {};\n\n  requestor.fetchFlagSettings = function(user, hash, callback) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n    let cb;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = user;\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n\n    const wrappedCallback = (function(currentCallback) {\n      return function(error, result) {\n        currentCallback(error, result);\n        flagSettingsRequest = null;\n        lastFlagSettingsCallback = null;\n      };\n    })(callback);\n\n    if (flagSettingsRequest) {\n      flagSettingsRequest.abort();\n      cb = (function(prevCallback) {\n        return function() {\n          prevCallback && prevCallback.apply(null, arguments);\n          wrappedCallback.apply(null, arguments);\n        };\n      })(lastFlagSettingsCallback);\n    } else {\n      cb = wrappedCallback;\n    }\n\n    lastFlagSettingsCallback = cb;\n    flagSettingsRequest = fetchJSON(endpoint, body, cb, sendLDHeaders);\n  };\n\n  requestor.fetchGoals = function(callback) {\n    const endpoint = [baseUrl, '/sdk/goals/', environment].join('');\n    fetchJSON(endpoint, null, callback, sendLDHeaders);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nfunction sanitizeUser(u) {\n  const sane = utils.clone(u);\n  if (sane.key) {\n    sane.key = sane.key.toString();\n  }\n  return sane;\n}\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = sanitizeUser(u);\n    onChange(utils.clone(user));\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport GoalTracker from './GoalTracker';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport * as utils from './utils';\nimport * as messages from './messages';\nimport * as errors from './errors';\n\nconst readyEvent = 'ready';\nconst successEvent = 'initialized';\nconst failedEvent = 'failed';\nconst changeEvent = 'change';\nconst goalsEvent = 'goalsReady';\nconst locationWatcherInterval = 300;\n\nexport function initialize(env, user, options = {}) {\n  const baseUrl = options.baseUrl || 'https://app.launchdarkly.com';\n  const eventsUrl = options.eventsUrl || 'https://events.launchdarkly.com';\n  const streamUrl = options.streamUrl || 'https://clientstream.launchdarkly.com';\n  const hash = options.hash;\n  const sendEvents = optionWithDefault('sendEvents', true);\n  const sendLDHeaders = optionWithDefault('sendLDHeaders', true);\n  const allowFrequentDuplicateEvents = !!options.allowFrequentDuplicateEvents;\n  const sendEventsOnlyForVariation = !!options.sendEventsOnlyForVariation;\n  const fetchGoals = typeof options.fetchGoals === 'undefined' ? true : options.fetchGoals;\n  const environment = env;\n  const emitter = EventEmitter();\n  const stream = Stream(streamUrl, environment, hash, options);\n  const events = options.eventProcessor || EventProcessor(eventsUrl, environment, options, emitter);\n  const requestor = Requestor(baseUrl, environment, options.useReport, options.evaluationReasons, sendLDHeaders);\n  const seenRequests = {};\n  let flags = typeof options.bootstrap === 'object' ? readFlagsFromBootstrap(options.bootstrap) : {};\n  let goalTracker;\n  let useLocalStorage;\n  let goals;\n  let streamActive;\n  let streamForcedState;\n  let subscribedToChangeEvents;\n  let firstEvent = true;\n\n  function optionWithDefault(name, defaultVal) {\n    return typeof options[name] === 'undefined' ? defaultVal : options[name];\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      console.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      console.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !doNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!event.user) {\n      if (firstEvent) {\n        if (console && console.warn) {\n          console.warn(\n            'Be sure to call `identify` in the LaunchDarkly client: http://docs.launchdarkly.com/docs/running-an-ab-test#include-the-client-side-snippet'\n          );\n        }\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  const ident = Identity(user, sendIdentifyEvent);\n  const store = Store(environment, hash, ident);\n\n  function sendFlagEvent(key, detail, defaultValue) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n      reason: detail ? detail.reason : null,\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      user: ident.getUser(),\n      creationDate: new Date().getTime(),\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return enqueueEvent(event);\n  }\n\n  function identify(user, hash, onDone) {\n    if (useLocalStorage) {\n      store.clearFlags();\n    }\n    return utils.wrapPromiseCallback(\n      new Promise((resolve, reject) => {\n        if (!user || user.key === null || user.key === undefined) {\n          const err = new errors.LDInvalidUserError(user ? messages.invalidUser() : messages.userNotSpecified());\n          emitter.maybeReportError(err);\n          reject(err);\n        } else {\n          ident.setUser(user);\n          requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n            if (err) {\n              emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n              return reject(err);\n            }\n            if (settings) {\n              updateSettings(settings);\n            }\n            resolve(utils.transformVersionedValuesToValues(settings));\n            if (streamActive) {\n              connectStream();\n            }\n          });\n        }\n      }),\n      onDone\n    );\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(\n      new Promise(resolve => (sendEvents ? resolve(events.flush()) : resolve()), onDone)\n    );\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent) {\n    let detail;\n\n    if (flags && flags.hasOwnProperty(key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function doNotTrack() {\n    let flag;\n    if (window.navigator && window.navigator.doNotTrack !== undefined) {\n      flag = window.navigator.doNotTrack; // FF, Chrome\n    } else if (window.navigator && window.navigator.msDoNotTrack !== undefined) {\n      flag = window.navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === '1' || flag === 'yes';\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key)) {\n        results[key] = variationDetailInternal(key, null, !sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function customEventExists(key) {\n    if (!goals || goals.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < goals.length; i++) {\n      if (goals[i].kind === 'custom' && goals[i].key === key) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function track(key, data) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    // Validate key if we have goals\n    if (!!goals && !customEventExists(key)) {\n      console.warn(messages.unknownCustomEventKey(key));\n    }\n\n    enqueueEvent({\n      kind: 'custom',\n      key: key,\n      data: data,\n      user: ident.getUser(),\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function connectStream() {\n    streamActive = true;\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), {\n      ping: function() {\n        requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n          if (err) {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          }\n          updateSettings(settings);\n        });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        updateSettings(data);\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          postProcessSettingsUpdate(mods);\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          postProcessSettingsUpdate(mods);\n        }\n      },\n    });\n  }\n\n  function disconnectStream() {\n    if (streamActive) {\n      stream.disconnect();\n      streamActive = false;\n    }\n  }\n\n  function updateSettings(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key) && flags[key]) {\n        if (newFlags[key] && !utils.deepEquals(newFlags[key].value, flags[key].value)) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (newFlags.hasOwnProperty(key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = newFlags;\n    postProcessSettingsUpdate(changes);\n  }\n\n  function postProcessSettingsUpdate(changes) {\n    const keys = Object.keys(changes);\n\n    if (useLocalStorage) {\n      store.saveFlags(flags);\n    }\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n\n      if (!sendEventsOnlyForVariation) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n  }\n\n  function on(event, handler, context) {\n    if (isChangeEventKey(event)) {\n      subscribedToChangeEvents = true;\n      if (!streamActive && streamForcedState === undefined) {\n        connectStream();\n      }\n      emitter.on(event, handler, context);\n    } else {\n      emitter.on(...arguments);\n    }\n  }\n\n  function off(event) {\n    emitter.off(...arguments);\n    if (isChangeEventKey(event)) {\n      let haveListeners = false;\n      emitter.getEvents().forEach(key => {\n        if (isChangeEventKey(key) && emitter.getEventListenerCount(key) > 0) {\n          haveListeners = true;\n        }\n      });\n      if (!haveListeners) {\n        subscribedToChangeEvents = false;\n        if (streamActive && streamForcedState === undefined) {\n          disconnectStream();\n        }\n      }\n    }\n  }\n\n  function setStreaming(state) {\n    const newState = state === null ? undefined : state;\n    if (newState !== streamForcedState) {\n      streamForcedState = newState;\n      const shouldBeStreaming = streamForcedState || (subscribedToChangeEvents && streamForcedState === undefined);\n      if (shouldBeStreaming && !streamActive) {\n        connectStream();\n      } else if (!shouldBeStreaming && streamActive) {\n        disconnectStream();\n      }\n    }\n  }\n\n  function isChangeEventKey(event) {\n    return event === changeEvent || event.substr(0, changeEvent.length + 1) === changeEvent + ':';\n  }\n\n  function handleMessage(event) {\n    if (event.origin !== baseUrl) {\n      return;\n    }\n    if (event.data.type === 'SYN') {\n      window.editorClientBaseUrl = baseUrl;\n      const editorTag = document.createElement('script');\n      editorTag.type = 'text/javascript';\n      editorTag.async = true;\n      editorTag.src = baseUrl + event.data.editorClientUrl;\n      const s = document.getElementsByTagName('script')[0];\n      s.parentNode.insertBefore(editorTag, s);\n    }\n  }\n\n  if (!env) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    });\n  }\n\n  if (!user) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    });\n  } else if (!user.key) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.invalidUser()));\n    });\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    utils.onNextTick(signalSuccessfulInit);\n  } else if (\n    typeof options.bootstrap === 'string' &&\n    options.bootstrap.toUpperCase() === 'LOCALSTORAGE' &&\n    !!window.localStorage\n  ) {\n    useLocalStorage = true;\n\n    flags = store.loadFlags();\n\n    if (flags === null) {\n      flags = {};\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n          signalFailedInit(initErr);\n        } else {\n          if (settings) {\n            updateSettings(settings); // this includes saving to local storage and sending change events\n          } else {\n            flags = {};\n          }\n          signalSuccessfulInit();\n        }\n      });\n    } else {\n      // We're reading the flags from local storage. Signal that we're ready immediately, but also\n      // start a request in the background to get newer flags. When we receive those, we will update\n      // localStorage, and will also send change events if the values have changed.\n      utils.onNextTick(signalSuccessfulInit);\n\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n        }\n        if (settings) {\n          updateSettings(settings); // this includes saving to local storage and sending change events\n        }\n      });\n    }\n  } else {\n    requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n      if (err) {\n        flags = {};\n        const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n        signalFailedInit(initErr);\n      } else {\n        flags = settings || {};\n        signalSuccessfulInit();\n      }\n    });\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = window.location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = window.location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (!!(window.history && window.history.pushState)) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  if (fetchGoals) {\n    requestor.fetchGoals((err, g) => {\n      if (err) {\n        emitter.maybeReportError(\n          new errors.LDUnexpectedResponseError('Error fetching goals: ' + err.message ? err.message : err)\n        );\n      }\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      emitter.emit(goalsEvent);\n    });\n  }\n\n  function signalSuccessfulInit() {\n    if (options.streaming !== undefined) {\n      setStreaming(options.streaming);\n    }\n    emitter.emit(readyEvent);\n    emitter.emit(successEvent); // allows initPromise to distinguish between success and failure\n  }\n\n  function signalFailedInit(err) {\n    emitter.maybeReportError(err);\n    emitter.emit(failedEvent, err);\n    emitter.emit(readyEvent); // for backward compatibility, this event happens even on failure\n  }\n\n  function start() {\n    if (sendEvents) {\n      events.start();\n    }\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', start);\n  } else {\n    start();\n  }\n\n  window.addEventListener('beforeunload', () => {\n    if (sendEvents) {\n      events.stop();\n      events.flush(true);\n    }\n  });\n\n  window.addEventListener('message', handleMessage);\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = emitter.on(readyEvent, () => {\n      emitter.off(readyEvent, onReady);\n      resolve();\n    });\n  });\n\n  const goalsPromise = new Promise(resolve => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n\n  const initPromise = new Promise((resolve, reject) => {\n    const onSuccess = emitter.on(successEvent, () => {\n      emitter.off(successEvent, onSuccess);\n      resolve();\n    });\n    const onFailure = emitter.on(failedEvent, err => {\n      emitter.off(failedEvent, onFailure);\n      reject(err);\n    });\n  });\n\n  const client = {\n    waitForInitialization: () => initPromise,\n    waitUntilReady: () => readyPromise,\n    waitUntilGoalsReady: () => goalsPromise,\n    identify: identify,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    setStreaming: setStreaming,\n    flush: flush,\n    allFlags: allFlags,\n  };\n\n  return client;\n}\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(messages.deprecated('default export', 'named LDClient export'));\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n","import { base64URLEncode } from './utils';\n\nexport default function Stream(baseUrl, environment, hash, config) {\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment + '/';\n  const useReport = (config && config.useReport) || false;\n  const withReasons = (config && config.evaluationReasons) || false;\n  const streamReconnectDelay = (config && config.streamReconnectDelay) || 1000;\n  const timeoutMillis = 300000; // 5 minutes (same as other SDKs) - note, this only has an effect on polyfills\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let user = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHandlers) {\n    user = newUser;\n    handlers = newHandlers;\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    closeConnection();\n  };\n\n  stream.isConnected = function() {\n    return es && (es.readyState === window.EventSource.OPEN || es.readyState === window.EventSource.CONNECTING);\n  };\n\n  function reconnect() {\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    let url;\n    let query = '';\n    if (typeof window.EventSource !== 'undefined') {\n      if (useReport) {\n        // we don't yet have an EventSource implementation that supports REPORT, so\n        // fall back to the old ping-based stream\n        url = baseUrl + '/ping/' + environment;\n      } else {\n        url = evalUrlPrefix + base64URLEncode(JSON.stringify(user));\n        if (hash !== null && hash !== undefined) {\n          query = 'h=' + hash;\n        }\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n\n      // The standard EventSource constructor doesn't take any options, just a URL. However, some\n      // EventSource polyfills allow us to specify a timeout interval, and in some cases they will\n      // default to a too-short timeout if we don't specify one. So, here, we are setting the\n      // timeout properties that are used by several popular polyfills.\n      const options = {\n        heartbeatTimeout: timeoutMillis, // used by \"event-source-polyfill\" package\n        silentTimeout: timeoutMillis, // used by \"eventsource-polyfill\" package\n      };\n\n      es = new window.EventSource(url, options);\n      for (const key in handlers) {\n        if (handlers.hasOwnProperty(key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = reconnect;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      es.close();\n      es = null;\n    }\n  }\n\n  return stream;\n}\n","import * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function Store(environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  store.loadFlags = function() {\n    const key = getFlagsKey();\n    let dataStr, data;\n    try {\n      dataStr = window.localStorage.getItem(key);\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n      return null;\n    }\n    try {\n      data = JSON.parse(dataStr);\n    } catch (ex) {\n      store.clearFlags();\n      return null;\n    }\n    if (data) {\n      const schema = data.$schema;\n      if (schema === undefined || schema < 1) {\n        data = utils.transformValuesToVersionedValues(data);\n      }\n    }\n    return data;\n  };\n\n  store.saveFlags = function(flags) {\n    const key = getFlagsKey();\n    const data = utils.extend({}, flags, { $schema: 1 });\n    try {\n      window.localStorage.setItem(key, JSON.stringify(data));\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n    }\n  };\n\n  store.clearFlags = function() {\n    const key = getFlagsKey();\n    try {\n      window.localStorage.removeItem(key);\n    } catch (ex) {}\n  };\n\n  return store;\n}\n"],"names":["createCustomError","name","CustomError","message","code","captureStackTrace","Error","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","uint8","tmp","len","length","extraBytes","parts","i","len2","push","encodeChunk","lookup","join","revLookup","charCodeAt","start","end","num","output","equal","a","b","arrA","Array","isArray","arrB","keys","Object","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","hasOwnProperty","call","btoa","s","escaped","unescape","encodeURIComponent","base64","stringToBytes","base64URLEncode","replace","clone","obj","JSON","parse","stringify","onNextTick","cb","wrapPromiseCallback","promise","callback","ret","then","value","Promise","reject","error","undefined","addLDHeaders","xhr","setRequestHeader","extend","objects","reduce","acc","MAX_URL_LENGTH","EventSender","eventsUrl","environmentId","forceHasCors","imageCreator","hasCors","postUrl","imageUrl","sender","loadUrlUsingImage","src","onDone","img","window","Image","addEventListener","sendChunk","events","usePost","sync","createImage","jsonBody","send","createRequest","canRetry","XMLHttpRequest","open","errors","dateStr","getResponseHeader","time","serverTime","getResponseInfo","utils","resolve","sendEvents","finalSync","chunks","maxLength","allEvents","slice","allChunks","remainingSpace","chunk","event","shift","unshift","results","all","docLink","localStorageUnavailable","unknownCustomEventKey","key","environmentNotFound","environmentNotSpecified","errorFetchingFlags","err","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","UserFilter","config","filter","allAttributesPrivate","all_attributes_private","privateAttributeNames","private_attribute_names","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","console","warn","messages","filterUser","user","userPrivateAttrs","filterAttrs","props","isAttributeAllowed","indexOf","isPrivateAttr","result","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","EventProcessor","es","startDate","endDate","counters","options","emitter","processor","eventSender","summarizer","summarizeEvent","kind","counterKey","variation","version","counterVal","count","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","clearSummary","userFilter","inlineUsers","inlineUsersInEvents","queue","flushInterval","samplingInterval","lastKnownPastTime","disabled","flushTimer","reportArgumentError","maybeReportError","shouldSampleEvent","Math","floor","random","isNaN","enqueue","e","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","responseInfo","setTimeout","flushTick","stop","EventEmitter","on","handler","concat","off","emit","apply","arguments","getEvents","getEventListenerCount","matchOperatorsRe","str","TypeError","doesUrlMatch","matcher","href","search","hash","canonicalUrl","regex","testUrl","escapeStringRegexp","url","substring","pattern","test","GoalTracker","goals","onEvent","tracker","listenerFn","clickGoals","goal","urls","j","location","matches","target","selector","elements","document","querySelectorAll","parentNode","findGoalsForClick","dispose","removeEventListener","json","fetchJSON","endpoint","body","sendLDHeaders","data","lastIndexOf","responseText","getResponseError","statusText","Identity","initialUser","onChange","ident","setUser","u","sane","sanitizeUser","getUser","readyEvent","successEvent","failedEvent","changeEvent","goalsEvent","locationWatcherInterval","initialize","env","baseUrl","streamUrl","optionWithDefault","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","fetchGoals","environment","stream","evalUrlPrefix","useReport","withReasons","evaluationReasons","streamReconnectDelay","timeoutMillis","reconnectTimeoutReference","handlers","reconnect","tryConnect","delay","openConnection","query","EventSource","onerror","closeConnection","close","connect","newUser","newHandlers","disconnect","isConnected","readyState","OPEN","CONNECTING","Stream","eventProcessor","requestor","flagSettingsRequest","lastFlagSettingsCallback","currentCallback","prevCallback","wrappedCallback","abort","Requestor","seenRequests","flags","_typeof","bootstrap","metadata","forEach","readFlagsFromBootstrap","goalTracker","useLocalStorage","streamActive","streamForcedState","subscribedToChangeEvents","firstEvent","defaultVal","shouldEnqueueEvent","navigator","doNotTrack","msDoNotTrack","enqueueEvent","store","getFlagsKey","loadFlags","dataStr","localStorage","getItem","ex","clearFlags","schema","$schema","saveFlags","setItem","removeItem","Store","sendFlagEvent","detail","defaultValue","now","cacheKey","cached","variationIndex","reason","flagVersion","sendGoalEvent","variationDetailInternal","sendEvent","deleted","getFlagDetail","errorKind","connectStream","fetchFlagSettings","settings","oldFlag","mods","newFlag","newDetail","previous","current","disconnectStream","updateSettings","newFlags","changes","fastDeepEqual","postProcessSettingsUpdate","changeEventParams","setStreaming","state","newState","shouldBeStreaming","isChangeEventKey","substr","refreshGoalTracker","signalSuccessfulInit","streaming","signalFailedInit","toUpperCase","g","interval","previousUrl","currentUrl","checkUrl","poll","fn","history","pushState","origin","type","editorClientBaseUrl","editorTag","createElement","async","editorClientUrl","getElementsByTagName","insertBefore","readyPromise","onReady","goalsPromise","onGoals","initPromise","onSuccess","onFailure","flagsState","customEventExists","haveListeners"],"mappings":"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"}