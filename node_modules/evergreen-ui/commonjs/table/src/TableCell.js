"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _toaster = require("../../toaster");

var _theme = require("../../theme");

var _layers = require("../../layers");

var _safeInvoke = _interopRequireDefault(require("../../lib/safe-invoke"));

var _TableRowContext = require("./TableRowContext");

var _manageTableCellFocusInteraction = _interopRequireDefault(require("./manageTableCellFocusInteraction"));

function executeArrowKeyOverride(override) {
  if (!override) {
    return;
  }

  if (typeof override === 'function') {
    override();
    return;
  }

  if (typeof override === 'string') {
    document.querySelector(override).focus();
    return;
  } // This needs to be the node, not a React ref.


  override.focus();
}

var TableCell =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(TableCell, _PureComponent);

  function TableCell() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TableCell);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TableCell)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleKeyDown", function (e) {
      var _this$props$arrowKeys = _this.props.arrowKeysOverrides,
          arrowKeysOverrides = _this$props$arrowKeys === void 0 ? {} : _this$props$arrowKeys;

      if (_this.props.isSelectable) {
        var key = e.key;

        if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
          e.preventDefault();

          try {
            // Support arrow key overrides.
            var override = arrowKeysOverrides[key.substr('Arrow'.length).toLowerCase()];
            if (override === false) return;
            if (override) return executeArrowKeyOverride(override);
            (0, _manageTableCellFocusInteraction.default)(key, _this.mainRef);
          } catch (error) {
            _toaster.toaster.danger('Keyboard interaction not possible');

            console.error('Keyboard interaction not possible', error);
          }
        } else if (key === 'Escape') {
          _this.mainRef.blur();
        }
      }

      (0, _safeInvoke.default)(_this.props.onKeyDown, e);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onRef", function (ref) {
      _this.mainRef = ref;
      (0, _safeInvoke.default)(_this.props.innerRef, ref);
    });
    return _this;
  }

  (0, _createClass2.default)(TableCell, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          innerRef = _this$props.innerRef,
          theme = _this$props.theme,
          children = _this$props.children,
          appearance = _this$props.appearance,
          onClick = _this$props.onClick,
          onKeyPress = _this$props.onKeyPress,
          onKeyDown = _this$props.onKeyDown,
          isSelectable = _this$props.isSelectable,
          _this$props$tabIndex = _this$props.tabIndex,
          tabIndex = _this$props$tabIndex === void 0 ? -1 : _this$props$tabIndex,
          className = _this$props.className,
          rightView = _this$props.rightView,
          arrowKeysOverrides = _this$props.arrowKeysOverrides,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["innerRef", "theme", "children", "appearance", "onClick", "onKeyPress", "onKeyDown", "isSelectable", "tabIndex", "className", "rightView", "arrowKeysOverrides"]);
      var themedClassName = theme.getTableCellClassName(appearance);
      return _react.default.createElement(_TableRowContext.TableRowConsumer, null, function (height) {
        return _react.default.createElement(_layers.Pane, (0, _extends2.default)({
          innerRef: _this2.onRef,
          height: height,
          className: (0, _classnames.default)(themedClassName, className),
          tabIndex: isSelectable ? tabIndex : undefined,
          "data-isselectable": isSelectable,
          onClick: onClick,
          onKeyDown: _this2.handleKeyDown
        }, TableCell.styles, props), children, rightView ? rightView : null);
      });
    }
  }]);
  return TableCell;
}(_react.PureComponent);

TableCell.displayName = "TableCell";
(0, _defineProperty2.default)(TableCell, "propTypes", (0, _objectSpread2.default)({}, _layers.Pane.propTypes, {
  /*
  * Makes the TableCell focusable. Used by EditableCell.
  * Will add tabIndex={-1 || this.props.tabIndex}.
  */
  isSelectable: _propTypes.default.bool,

  /**
   * The appearance of the table row. Default theme only support default.
   */
  appearance: _propTypes.default.string.isRequired,

  /**
   * Optional node to be placed on the right side of the table cell.
   * Useful for icons and icon buttons.
   */
  rightView: _propTypes.default.node,

  /**
   * Theme provided by ThemeProvider.
   */
  theme: _propTypes.default.object.isRequired,

  /**
   * Advanced arrow keys overrides for selectable cells.
   * A string will be used as a selector.
   */
  arrowKeysOverrides: _propTypes.default.shape({
    up: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.element, _propTypes.default.oneOf([false])]),
    down: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.element, _propTypes.default.oneOf([false])]),
    left: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.element, _propTypes.default.oneOf([false])]),
    right: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.element, _propTypes.default.oneOf([false])])
  }),

  /**
   * Class name passed to the table cell.
   * Only use if you know what you are doing.
   */
  className: _propTypes.default.string
}));
(0, _defineProperty2.default)(TableCell, "defaultProps", {
  appearance: 'default'
});
(0, _defineProperty2.default)(TableCell, "styles", {
  paddingX: 12,
  boxSizing: 'border-box',
  flex: 1,
  display: 'flex',
  alignItems: 'center',
  flexShrink: 0,
  overflow: 'hidden'
});

var _default = (0, _theme.withTheme)(TableCell);

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVDZWxsLmpzIl0sIm5hbWVzIjpbImV4ZWN1dGVBcnJvd0tleU92ZXJyaWRlIiwib3ZlcnJpZGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJmb2N1cyIsIlRhYmxlQ2VsbCIsImUiLCJwcm9wcyIsImFycm93S2V5c092ZXJyaWRlcyIsImlzU2VsZWN0YWJsZSIsImtleSIsInByZXZlbnREZWZhdWx0Iiwic3Vic3RyIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJtYWluUmVmIiwiZXJyb3IiLCJ0b2FzdGVyIiwiZGFuZ2VyIiwiY29uc29sZSIsImJsdXIiLCJvbktleURvd24iLCJyZWYiLCJpbm5lclJlZiIsInRoZW1lIiwiY2hpbGRyZW4iLCJhcHBlYXJhbmNlIiwib25DbGljayIsIm9uS2V5UHJlc3MiLCJ0YWJJbmRleCIsImNsYXNzTmFtZSIsInJpZ2h0VmlldyIsInRoZW1lZENsYXNzTmFtZSIsImdldFRhYmxlQ2VsbENsYXNzTmFtZSIsImhlaWdodCIsIm9uUmVmIiwidW5kZWZpbmVkIiwiaGFuZGxlS2V5RG93biIsInN0eWxlcyIsIlB1cmVDb21wb25lbnQiLCJQYW5lIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiYm9vbCIsInN0cmluZyIsImlzUmVxdWlyZWQiLCJub2RlIiwib2JqZWN0Iiwic2hhcGUiLCJ1cCIsIm9uZU9mVHlwZSIsImZ1bmMiLCJlbGVtZW50Iiwib25lT2YiLCJkb3duIiwibGVmdCIsInJpZ2h0IiwicGFkZGluZ1giLCJib3hTaXppbmciLCJmbGV4IiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJmbGV4U2hyaW5rIiwib3ZlcmZsb3ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxTQUFTQSx1QkFBVCxDQUFpQ0MsUUFBakMsRUFB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QUFVUSxTQUFWLENBQW9CLENBQ3hCUixtQkFBVUUsTUFEYyxFQUV4QkYsbUJBQVVTLElBRmMsRUFHeEJULG1CQUFVVSxPQUhjLEVBSXhCVixtQkFBVVcsS0FBVixDQUFnQixDQUFDLEtBQUQsQ0FBaEIsQ0FKd0IsQ0FBcEIsQ0FiNEI7QUFtQmxDRyxJQUFBQSxLQUFLLEVBQUVkLG1CQUFVUSxTQUFWLENBQW9CLENBQ3pCUixtQkFBVUUsTUFEZSxFQUV6QkYsbUJBQVVTLElBRmUsRUFHekJULG1CQUFVVSxPQUhlLEVBSXpCVixtQkFBVVcsS0FBVixDQUFnQixDQUFDLEtBQUQsQ0FBaEIsQ0FKeUIsQ0FBcEI7QUFuQjJCLEdBQWhCLEM7O0FBMkJwQjs7OztBQUlBdkIsRUFBQUEsU0FBUyxFQUFFWSxtQkFBVUU7OzhCQWhFbkJ2QyxTLGtCQW1Fa0I7QUFDcEJxQixFQUFBQSxVQUFVLEVBQUU7QUFEUSxDOzhCQW5FbEJyQixTLFlBdUVZO0FBQ2RvRCxFQUFBQSxRQUFRLEVBQUUsRUFESTtBQUVkQyxFQUFBQSxTQUFTLEVBQUUsWUFGRztBQUdkQyxFQUFBQSxJQUFJLEVBQUUsQ0FIUTtBQUlkQyxFQUFBQSxPQUFPLEVBQUUsTUFKSztBQUtkQyxFQUFBQSxVQUFVLEVBQUUsUUFMRTtBQU1kQyxFQUFBQSxVQUFVLEVBQUUsQ0FORTtBQU9kQyxFQUFBQSxRQUFRLEVBQUU7QUFQSSxDOztlQTJGSCxzQkFBVTFELFNBQVYsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcydcbmltcG9ydCB7IHRvYXN0ZXIgfSBmcm9tICcuLi8uLi90b2FzdGVyJ1xuaW1wb3J0IHsgd2l0aFRoZW1lIH0gZnJvbSAnLi4vLi4vdGhlbWUnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IHNhZmVJbnZva2UgZnJvbSAnLi4vLi4vbGliL3NhZmUtaW52b2tlJ1xuaW1wb3J0IHsgVGFibGVSb3dDb25zdW1lciB9IGZyb20gJy4vVGFibGVSb3dDb250ZXh0J1xuaW1wb3J0IG1hbmFnZVRhYmxlQ2VsbEZvY3VzSW50ZXJhY3Rpb24gZnJvbSAnLi9tYW5hZ2VUYWJsZUNlbGxGb2N1c0ludGVyYWN0aW9uJ1xuXG5mdW5jdGlvbiBleGVjdXRlQXJyb3dLZXlPdmVycmlkZShvdmVycmlkZSkge1xuICBpZiAoIW92ZXJyaWRlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBvdmVycmlkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG92ZXJyaWRlKClcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodHlwZW9mIG92ZXJyaWRlID09PSAnc3RyaW5nJykge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3ZlcnJpZGUpLmZvY3VzKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgdGhlIG5vZGUsIG5vdCBhIFJlYWN0IHJlZi5cbiAgb3ZlcnJpZGUuZm9jdXMoKVxufVxuXG5jbGFzcyBUYWJsZUNlbGwgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21wb3NlcyB0aGUgUGFuZSBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uUGFuZS5wcm9wVHlwZXMsXG5cbiAgICAvKlxuICAgICogTWFrZXMgdGhlIFRhYmxlQ2VsbCBmb2N1c2FibGUuIFVzZWQgYnkgRWRpdGFibGVDZWxsLlxuICAgICogV2lsbCBhZGQgdGFiSW5kZXg9ey0xIHx8IHRoaXMucHJvcHMudGFiSW5kZXh9LlxuICAgICovXG4gICAgaXNTZWxlY3RhYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJsZSByb3cuIERlZmF1bHQgdGhlbWUgb25seSBzdXBwb3J0IGRlZmF1bHQuXG4gICAgICovXG4gICAgYXBwZWFyYW5jZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgbm9kZSB0byBiZSBwbGFjZWQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRhYmxlIGNlbGwuXG4gICAgICogVXNlZnVsIGZvciBpY29ucyBhbmQgaWNvbiBidXR0b25zLlxuICAgICAqL1xuICAgIHJpZ2h0VmlldzogUHJvcFR5cGVzLm5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBUaGVtZSBwcm92aWRlZCBieSBUaGVtZVByb3ZpZGVyLlxuICAgICAqL1xuICAgIHRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlZCBhcnJvdyBrZXlzIG92ZXJyaWRlcyBmb3Igc2VsZWN0YWJsZSBjZWxscy5cbiAgICAgKiBBIHN0cmluZyB3aWxsIGJlIHVzZWQgYXMgYSBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBhcnJvd0tleXNPdmVycmlkZXM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICB1cDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgICAgUHJvcFR5cGVzLm9uZU9mKFtmYWxzZV0pXG4gICAgICBdKSxcbiAgICAgIGRvd246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgICAgIFByb3BUeXBlcy5vbmVPZihbZmFsc2VdKVxuICAgICAgXSksXG4gICAgICBsZWZ0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIFByb3BUeXBlcy5lbGVtZW50LFxuICAgICAgICBQcm9wVHlwZXMub25lT2YoW2ZhbHNlXSlcbiAgICAgIF0pLFxuICAgICAgcmlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBQcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgUHJvcFR5cGVzLmVsZW1lbnQsXG4gICAgICAgIFByb3BUeXBlcy5vbmVPZihbZmFsc2VdKVxuICAgICAgXSlcbiAgICB9KSxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIG5hbWUgcGFzc2VkIHRvIHRoZSB0YWJsZSBjZWxsLlxuICAgICAqIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgYXBwZWFyYW5jZTogJ2RlZmF1bHQnXG4gIH1cblxuICBzdGF0aWMgc3R5bGVzID0ge1xuICAgIHBhZGRpbmdYOiAxMixcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmbGV4OiAxLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgIGNvbnN0IHsgYXJyb3dLZXlzT3ZlcnJpZGVzID0ge30gfSA9IHRoaXMucHJvcHNcblxuICAgIGlmICh0aGlzLnByb3BzLmlzU2VsZWN0YWJsZSkge1xuICAgICAgY29uc3QgeyBrZXkgfSA9IGVcbiAgICAgIGlmIChcbiAgICAgICAga2V5ID09PSAnQXJyb3dVcCcgfHxcbiAgICAgICAga2V5ID09PSAnQXJyb3dEb3duJyB8fFxuICAgICAgICBrZXkgPT09ICdBcnJvd0xlZnQnIHx8XG4gICAgICAgIGtleSA9PT0gJ0Fycm93UmlnaHQnXG4gICAgICApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU3VwcG9ydCBhcnJvdyBrZXkgb3ZlcnJpZGVzLlxuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlID1cbiAgICAgICAgICAgIGFycm93S2V5c092ZXJyaWRlc1trZXkuc3Vic3RyKCdBcnJvdycubGVuZ3RoKS50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVyblxuICAgICAgICAgIGlmIChvdmVycmlkZSkgcmV0dXJuIGV4ZWN1dGVBcnJvd0tleU92ZXJyaWRlKG92ZXJyaWRlKVxuXG4gICAgICAgICAgbWFuYWdlVGFibGVDZWxsRm9jdXNJbnRlcmFjdGlvbihrZXksIHRoaXMubWFpblJlZilcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0b2FzdGVyLmRhbmdlcignS2V5Ym9hcmQgaW50ZXJhY3Rpb24gbm90IHBvc3NpYmxlJylcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdLZXlib2FyZCBpbnRlcmFjdGlvbiBub3QgcG9zc2libGUnLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIHRoaXMubWFpblJlZi5ibHVyKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzYWZlSW52b2tlKHRoaXMucHJvcHMub25LZXlEb3duLCBlKVxuICB9XG5cbiAgb25SZWYgPSByZWYgPT4ge1xuICAgIHRoaXMubWFpblJlZiA9IHJlZlxuICAgIHNhZmVJbnZva2UodGhpcy5wcm9wcy5pbm5lclJlZiwgcmVmKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlubmVyUmVmLFxuICAgICAgdGhlbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFwcGVhcmFuY2UsXG4gICAgICBvbkNsaWNrLFxuICAgICAgb25LZXlQcmVzcyxcbiAgICAgIG9uS2V5RG93bixcbiAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgIHRhYkluZGV4ID0gLTEsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICByaWdodFZpZXcsXG4gICAgICBhcnJvd0tleXNPdmVycmlkZXMsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB0aGVtZWRDbGFzc05hbWUgPSB0aGVtZS5nZXRUYWJsZUNlbGxDbGFzc05hbWUoYXBwZWFyYW5jZSlcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVSb3dDb25zdW1lcj5cbiAgICAgICAge2hlaWdodCA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxQYW5lXG4gICAgICAgICAgICAgIGlubmVyUmVmPXt0aGlzLm9uUmVmfVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjeCh0aGVtZWRDbGFzc05hbWUsIGNsYXNzTmFtZSl9XG4gICAgICAgICAgICAgIHRhYkluZGV4PXtpc1NlbGVjdGFibGUgPyB0YWJJbmRleCA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgZGF0YS1pc3NlbGVjdGFibGU9e2lzU2VsZWN0YWJsZX1cbiAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleURvd259XG4gICAgICAgICAgICAgIHsuLi5UYWJsZUNlbGwuc3R5bGVzfVxuICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAge3JpZ2h0VmlldyA/IHJpZ2h0VmlldyA6IG51bGx9XG4gICAgICAgICAgICA8L1BhbmU+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9UYWJsZVJvd0NvbnN1bWVyPlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoVGFibGVDZWxsKVxuIl19