"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _theme = require("../../theme");

var _portal = require("../../portal");

var _stack = require("../../stack");

var _safeInvoke = _interopRequireDefault(require("../../lib/safe-invoke"));

var _TextTableCell = _interopRequireDefault(require("./TextTableCell"));

var _TableCell = _interopRequireDefault(require("./TableCell"));

var _EditableCellField = _interopRequireDefault(require("./EditableCellField"));

var EditableCell =
/*#__PURE__*/
function (_React$PureComponent) {
  (0, _inherits2.default)(EditableCell, _React$PureComponent);

  function EditableCell() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, EditableCell);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(EditableCell)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "state", {
      value: _this.props.children
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onMainRef", function (ref) {
      _this.mainRef = ref;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "onOverlayRef", function (ref) {
      _this.overlayRef = ref;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleDoubleClick", function () {
      if (_this.props.disabled || !_this.props.isSelectable) return;

      _this.setState({
        isEditing: true
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleKeyDown", function (e) {
      if (_this.props.disabled) return;
      var key = e.key;
      /**
       * When the user presses a character on the keyboard, use that character
       * as the value in the text field.
       */

      if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {
        _this.setState({
          isEditing: true,
          value: key
        });
      } else if (key === 'Enter') {
        _this.setState({
          isEditing: true
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleFieldChangeComplete", function (value) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          isSelectable = _this$props.isSelectable;
      var currentValue = _this.state.value;

      _this.setState({
        isEditing: false,
        value: value
      });

      if (currentValue !== value) {
        (0, _safeInvoke.default)(onChange, value);
      }

      if (_this.mainRef && isSelectable) {
        _this.mainRef.focus();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleFieldCancel", function () {
      _this.setState({
        isEditing: false
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleClick", function () {
      _this.mainRef.focus();
    });
    return _this;
  }

  (0, _createClass2.default)(EditableCell, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          children = _this$props2.children,
          theme = _this$props2.theme,
          size = _this$props2.size,
          disabled = _this$props2.disabled,
          placeholder = _this$props2.placeholder,
          isSelectable = _this$props2.isSelectable,
          _this$props2$textProp = _this$props2.textProps,
          textProps = _this$props2$textProp === void 0 ? {} : _this$props2$textProp,
          props = (0, _objectWithoutProperties2.default)(_this$props2, ["children", "theme", "size", "disabled", "placeholder", "isSelectable", "textProps"]);
      var _this$state = this.state,
          isEditing = _this$state.isEditing,
          value = _this$state.value;
      return _react.default.createElement(_react.default.Fragment, null, _react.default.createElement(_TextTableCell.default, (0, _extends2.default)({
        innerRef: this.onMainRef,
        isSelectable: isSelectable && !disabled,
        onClick: this.handleClick,
        onDoubleClick: this.handleDoubleClick,
        onKeyDown: this.handleKeyDown,
        cursor: disabled ? 'not-allowed' : isSelectable ? 'default' : 'text',
        textProps: (0, _objectSpread2.default)({
          size: size,
          opacity: disabled || !children && placeholder ? 0.5 : 1
        }, textProps)
      }, props), children ? children : placeholder), isEditing && _react.default.createElement(_portal.Portal, null, _react.default.createElement(_stack.Stack, null, function (zIndex) {
        return _react.default.createElement(_EditableCellField.default, {
          zIndex: zIndex,
          getTargetRef: function getTargetRef() {
            return _this2.mainRef;
          },
          value: value,
          onEscape: _this2.handleFieldEscape,
          onChangeComplete: _this2.handleFieldChangeComplete,
          onCancel: _this2.handleFieldCancel,
          size: size
        });
      })));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (props.children !== state.value) {
        return {
          value: props.children
        };
      }

      return null;
    }
  }]);
  return EditableCell;
}(_react.default.PureComponent);

EditableCell.displayName = "EditableCell";
(0, _defineProperty2.default)(EditableCell, "propTypes", (0, _objectSpread2.default)({}, _TableCell.default.propTypes, {
  /*
  * Makes the TableCell focusable.
  * Will add tabIndex={-1 || this.props.tabIndex}.
  */
  isSelectable: _propTypes.default.bool.isRequired,

  /**
   * When true, the cell can't be edited.
   */
  disabled: _propTypes.default.bool,

  /**
   * Optional placeholder when children is falsy.
   */
  placeholder: _propTypes.default.node,

  /**
   * The size used for the TextTableCell and Textarea.
   */
  size: _propTypes.default.oneOf([300, 400]).isRequired,

  /**
   * This is the value of the cell.
   */
  children: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /**
   * Function called when value changes. (value: string) => void.
   */
  onChange: _propTypes.default.func
}));
(0, _defineProperty2.default)(EditableCell, "defaultProps", {
  size: 300,
  isSelectable: true
});

var _default = (0, _theme.withTheme)(EditableCell);

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvRWRpdGFibGVDZWxsLmpzIl0sIm5hbWVzIjpbIkVkaXRhYmxlQ2VsbCIsInZhbHVlIiwicHJvcHMiLCJjaGlsZHJlbiIsInJlZiIsIm1haW5SZWYiLCJvdmVybGF5UmVmIiwiZGlzYWJsZWQiLCJpc1NlbGVjdGFibGUiLCJzZXRTdGF0ZSIsImlzRWRpdGluZyIsImUiLCJrZXkiLCJtYXRjaCIsIm1ldGFLZXkiLCJjdHJsS2V5IiwiYWx0S2V5Iiwib25DaGFuZ2UiLCJjdXJyZW50VmFsdWUiLCJzdGF0ZSIsImZvY3VzIiwidGhlbWUiLCJzaXplIiwicGxhY2Vob2xkZXIiLCJ0ZXh0UHJvcHMiLCJvbk1haW5SZWYiLCJoYW5kbGVDbGljayIsImhhbmRsZURvdWJsZUNsaWNrIiwiaGFuZGxlS2V5RG93biIsIm9wYWNpdHkiLCJ6SW5kZXgiLCJoYW5kbGVGaWVsZEVzY2FwZSIsImhhbmRsZUZpZWxkQ2hhbmdlQ29tcGxldGUiLCJoYW5kbGVGaWVsZENhbmNlbCIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsIlRhYmxlQ2VsbCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImJvb2wiLCJpc1JlcXVpcmVkIiwibm9kZSIsIm9uZU9mIiwib25lT2ZUeXBlIiwic3RyaW5nIiwibnVtYmVyIiwiZnVuYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7SUFFTUEsWTs7Ozs7Ozs7Ozs7Ozs7Ozs7OEhBcURJO0FBQ05DLE1BQUFBLEtBQUssRUFBRSxNQUFLQyxLQUFMLENBQVdDO0FBRFosSztrSUFJSSxVQUFBQyxHQUFHLEVBQUk7QUFDakIsWUFBS0MsT0FBTCxHQUFlRCxHQUFmO0FBQ0QsSztxSUFFYyxVQUFBQSxHQUFHLEVBQUk7QUFDcEIsWUFBS0UsVUFBTCxHQUFrQkYsR0FBbEI7QUFDRCxLOzBJQUVt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VixDQUFnQixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQWhCLEVBQTRCRixVOztBQUVsQzs7O0FBR0FyQyxFQUFBQSxRQUFRLEVBQUVtQyxtQkFBVUssU0FBVixDQUFvQixDQUFDTCxtQkFBVU0sTUFBWCxFQUFtQk4sbUJBQVVPLE1BQTdCLENBQXBCLEM7O0FBRVY7OztBQUdBNUIsRUFBQUEsUUFBUSxFQUFFcUIsbUJBQVVROzs4QkFwQ2xCOUMsWSxrQkF1Q2tCO0FBQ3BCc0IsRUFBQUEsSUFBSSxFQUFFLEdBRGM7QUFFcEJkLEVBQUFBLFlBQVksRUFBRTtBQUZNLEM7O2VBcUlULHNCQUFVUixZQUFWLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyB3aXRoVGhlbWUgfSBmcm9tICcuLi8uLi90aGVtZSdcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gJy4uLy4uL3BvcnRhbCdcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnLi4vLi4vc3RhY2snXG5pbXBvcnQgc2FmZUludm9rZSBmcm9tICcuLi8uLi9saWIvc2FmZS1pbnZva2UnXG5pbXBvcnQgVGV4dFRhYmxlQ2VsbCBmcm9tICcuL1RleHRUYWJsZUNlbGwnXG5pbXBvcnQgVGFibGVDZWxsIGZyb20gJy4vVGFibGVDZWxsJ1xuaW1wb3J0IEVkaXRhYmxlQ2VsbEZpZWxkIGZyb20gJy4vRWRpdGFibGVDZWxsRmllbGQnXG5cbmNsYXNzIEVkaXRhYmxlQ2VsbCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBUYWJsZUNlbGwgY29tcG9uZW50IGFzIHRoZSBiYXNlLlxuICAgICAqL1xuICAgIC4uLlRhYmxlQ2VsbC5wcm9wVHlwZXMsXG5cbiAgICAvKlxuICAgICogTWFrZXMgdGhlIFRhYmxlQ2VsbCBmb2N1c2FibGUuXG4gICAgKiBXaWxsIGFkZCB0YWJJbmRleD17LTEgfHwgdGhpcy5wcm9wcy50YWJJbmRleH0uXG4gICAgKi9cbiAgICBpc1NlbGVjdGFibGU6IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBjZWxsIGNhbid0IGJlIGVkaXRlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBwbGFjZWhvbGRlciB3aGVuIGNoaWxkcmVuIGlzIGZhbHN5LlxuICAgICAqL1xuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMubm9kZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIHVzZWQgZm9yIHRoZSBUZXh0VGFibGVDZWxsIGFuZCBUZXh0YXJlYS5cbiAgICAgKi9cbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWzMwMCwgNDAwXSkuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHZhbHVlIG9mIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiB2YWx1ZSBjaGFuZ2VzLiAodmFsdWU6IHN0cmluZykgPT4gdm9pZC5cbiAgICAgKi9cbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmNcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgc2l6ZTogMzAwLFxuICAgIGlzU2VsZWN0YWJsZTogdHJ1ZVxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAocHJvcHMuY2hpbGRyZW4gIT09IHN0YXRlLnZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcHJvcHMuY2hpbGRyZW5cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHN0YXRlID0ge1xuICAgIHZhbHVlOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gIH1cblxuICBvbk1haW5SZWYgPSByZWYgPT4ge1xuICAgIHRoaXMubWFpblJlZiA9IHJlZlxuICB9XG5cbiAgb25PdmVybGF5UmVmID0gcmVmID0+IHtcbiAgICB0aGlzLm92ZXJsYXlSZWYgPSByZWZcbiAgfVxuXG4gIGhhbmRsZURvdWJsZUNsaWNrID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8ICF0aGlzLnByb3BzLmlzU2VsZWN0YWJsZSkgcmV0dXJuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzRWRpdGluZzogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVLZXlEb3duID0gZSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHJldHVyblxuICAgIGNvbnN0IHsga2V5IH0gPSBlXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSB1c2VyIHByZXNzZXMgYSBjaGFyYWN0ZXIgb24gdGhlIGtleWJvYXJkLCB1c2UgdGhhdCBjaGFyYWN0ZXJcbiAgICAgKiBhcyB0aGUgdmFsdWUgaW4gdGhlIHRleHQgZmllbGQuXG4gICAgICovXG4gICAgaWYgKGtleS5tYXRjaCgvXlthLXpdezAsMTB9JC8pICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5hbHRLZXkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0VkaXRpbmc6IHRydWUsXG4gICAgICAgIHZhbHVlOiBrZXlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0VkaXRpbmc6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRmllbGRDaGFuZ2VDb21wbGV0ZSA9IHZhbHVlID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBpc1NlbGVjdGFibGUgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgICB2YWx1ZVxuICAgIH0pXG5cbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgc2FmZUludm9rZShvbkNoYW5nZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFpblJlZiAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgIHRoaXMubWFpblJlZi5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRmllbGRDYW5jZWwgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzRWRpdGluZzogZmFsc2UgfSlcbiAgfVxuXG4gIGhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMubWFpblJlZi5mb2N1cygpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICB0aGVtZSxcbiAgICAgIHNpemUsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgdGV4dFByb3BzID0ge30sXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBpc0VkaXRpbmcsIHZhbHVlIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICA8VGV4dFRhYmxlQ2VsbFxuICAgICAgICAgIGlubmVyUmVmPXt0aGlzLm9uTWFpblJlZn1cbiAgICAgICAgICBpc1NlbGVjdGFibGU9e2lzU2VsZWN0YWJsZSAmJiAhZGlzYWJsZWR9XG4gICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgICBvbkRvdWJsZUNsaWNrPXt0aGlzLmhhbmRsZURvdWJsZUNsaWNrfVxuICAgICAgICAgIG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXlEb3dufVxuICAgICAgICAgIGN1cnNvcj17ZGlzYWJsZWQgPyAnbm90LWFsbG93ZWQnIDogaXNTZWxlY3RhYmxlID8gJ2RlZmF1bHQnIDogJ3RleHQnfVxuICAgICAgICAgIHRleHRQcm9wcz17e1xuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IGRpc2FibGVkIHx8ICghY2hpbGRyZW4gJiYgcGxhY2Vob2xkZXIpID8gMC41IDogMSxcbiAgICAgICAgICAgIC4uLnRleHRQcm9wc1xuICAgICAgICAgIH19XG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVuID8gY2hpbGRyZW4gOiBwbGFjZWhvbGRlcn1cbiAgICAgICAgPC9UZXh0VGFibGVDZWxsPlxuICAgICAgICB7aXNFZGl0aW5nICYmIChcbiAgICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgICAgPFN0YWNrPlxuICAgICAgICAgICAgICB7ekluZGV4ID0+IChcbiAgICAgICAgICAgICAgICA8RWRpdGFibGVDZWxsRmllbGRcbiAgICAgICAgICAgICAgICAgIHpJbmRleD17ekluZGV4fVxuICAgICAgICAgICAgICAgICAgZ2V0VGFyZ2V0UmVmPXsoKSA9PiB0aGlzLm1haW5SZWZ9XG4gICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICBvbkVzY2FwZT17dGhpcy5oYW5kbGVGaWVsZEVzY2FwZX1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ29tcGxldGU9e3RoaXMuaGFuZGxlRmllbGRDaGFuZ2VDb21wbGV0ZX1cbiAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsPXt0aGlzLmhhbmRsZUZpZWxkQ2FuY2VsfVxuICAgICAgICAgICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9TdGFjaz5cbiAgICAgICAgICA8L1BvcnRhbD5cbiAgICAgICAgKX1cbiAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhUaGVtZShFZGl0YWJsZUNlbGwpXG4iXX0=