"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _fuzzaldrinPlus = _interopRequireDefault(require("fuzzaldrin-plus"));

var _reactTinyVirtualList = _interopRequireDefault(require("react-tiny-virtual-list"));

var _layers = require("../../layers");

var _table = require("../../table");

var _OptionShapePropType = _interopRequireDefault(require("./OptionShapePropType"));

var _Option = _interopRequireDefault(require("./Option"));

/**
 * Fuzzaldrin-plus is the default filter, but you can use your own
 * as long as they follow the following signature:
 * @param options <Array[String]> - ['label', 'label2', ...]
 * @param input <String>
 */
var fuzzyFilter = function fuzzyFilter(options, input) {
  return _fuzzaldrinPlus.default.filter(options, input);
};
/**
 * This is the default item renderer of options
 * you can pass custom renderers as long as they work the same as the Option
 */


var itemRenderer = function itemRenderer(props) {
  return _react.default.createElement(_Option.default, props);
};

itemRenderer.displayName = "itemRenderer";

var OptionsList =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(OptionsList, _PureComponent);

  function OptionsList(props, context) {
    var _this;

    (0, _classCallCheck2.default)(this, OptionsList);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OptionsList).call(this, props, context));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "isSelected", function (item) {
      var selected = _this.state.selected;
      return Boolean(selected.find(function (selectedItem) {
        return selectedItem === item.value;
      }));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "search", function (options) {
      var optionsFilter = _this.props.optionsFilter;
      var searchValue = _this.state.searchValue;
      return searchValue.trim() === '' ? options // Return if no search query
      : optionsFilter(options.map(function (item) {
        return item.labelInList || item.label;
      }), searchValue).map(function (name) {
        return options.find(function (item) {
          return item.labelInList === name || item.label === name;
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "getCurrentIndex", function () {
      var selected = _this.props.selected;

      var options = _this.getFilteredOptions();

      return options.findIndex(function (option) {
        return option.value === selected[selected.length - 1];
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleKeyDown", function (e) {
      if (e.keyCode === 38) {
        _this.handleArrowUp();
      }

      if (e.keyCode === 40) {
        _this.handleArrowDown();
      }

      if (e.keyCode === 13) {
        _this.handleEnter();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleArrowUp", function () {
      var onSelect = _this.props.onSelect;

      var options = _this.getFilteredOptions();

      var nextIndex = _this.getCurrentIndex() - 1;

      if (nextIndex < 0) {
        nextIndex = options.length - 1;
      }

      onSelect(options[nextIndex]);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleArrowDown", function () {
      var onSelect = _this.props.onSelect;

      var options = _this.getFilteredOptions();

      var nextIndex = _this.getCurrentIndex() + 1;

      if (nextIndex === options.length) {
        nextIndex = 0;
      }

      onSelect(options[nextIndex]);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleEnter", function () {
      var isSelected = _this.getCurrentIndex() !== -1;

      if (isSelected) {
        _this.props.close();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleChange", function (searchValue) {
      _this.setState({
        searchValue: searchValue
      });

      _this.props.onFilterChange(searchValue);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleSelect", function (item) {
      _this.props.onSelect(item);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "handleDeselect", function (item) {
      _this.props.onDeselect(item);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "assignSearchRef", function (ref) {
      _this.searchRef = ref;
    });
    _this.state = {
      searchValue: props.defaultSearchValue,
      selected: props.selected
    };
    return _this;
  }

  (0, _createClass2.default)(OptionsList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var hasFilter = this.props.hasFilter;
      if (!hasFilter) return;
      /**
       * Hacky solution for broken autoFocus
       * https://github.com/segmentio/evergreen/issues/90
       */

      requestAnimationFrame(function () {
        _this2.searchRef.querySelector('input').focus();
      });
      window.addEventListener('keydown', this.handleKeyDown);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('keydown', this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.selected !== this.props.selected) {
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          selected: this.props.selected
        });
      }
    }
  }, {
    key: "getFilteredOptions",
    value: function getFilteredOptions() {
      var options = this.props.options;
      return this.search(options);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props = this.props,
          originalOptions = _this$props.options,
          close = _this$props.close,
          width = _this$props.width,
          height = _this$props.height,
          onSelect = _this$props.onSelect,
          onDeselect = _this$props.onDeselect,
          selected = _this$props.selected,
          hasFilter = _this$props.hasFilter,
          optionSize = _this$props.optionSize,
          _renderItem = _this$props.renderItem,
          placeholder = _this$props.placeholder,
          optionsFilter = _this$props.optionsFilter,
          isMultiSelect = _this$props.isMultiSelect,
          defaultSearchValue = _this$props.defaultSearchValue,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["options", "close", "width", "height", "onSelect", "onDeselect", "selected", "hasFilter", "optionSize", "renderItem", "placeholder", "optionsFilter", "isMultiSelect", "defaultSearchValue"]);
      var options = this.search(originalOptions);
      var listHeight = height - (hasFilter ? 32 : 0);
      var currentIndex = this.getCurrentIndex();
      var scrollToIndex = currentIndex === -1 ? 0 : currentIndex;
      return _react.default.createElement(_layers.Pane, (0, _extends2.default)({
        height: height,
        width: width,
        display: "flex",
        flexDirection: "column"
      }, props), hasFilter && _react.default.createElement(_table.TableHead, null, _react.default.createElement(_table.SearchTableHeaderCell, {
        onChange: this.handleChange,
        innerRef: this.assignSearchRef,
        borderRight: null,
        height: 32
      })), _react.default.createElement(_layers.Pane, {
        flex: 1
      }, _react.default.createElement(_reactTinyVirtualList.default, (0, _extends2.default)({
        height: listHeight,
        width: "100%",
        itemSize: optionSize,
        itemCount: options.length,
        overscanCount: 20,
        scrollToAlignment: "auto"
      }, scrollToIndex ? {
        scrollToIndex: scrollToIndex
      } : {}, {
        renderItem: function renderItem(_ref) {
          var index = _ref.index,
              style = _ref.style;
          var item = options[index];

          var isSelected = _this3.isSelected(item);

          return _renderItem({
            key: item.value,
            label: item.label,
            style: style,
            height: optionSize,
            onSelect: function onSelect() {
              return _this3.handleSelect(item);
            },
            onDeselect: function onDeselect() {
              return _this3.handleDeselect(item);
            },
            isSelectable: !isSelected || isMultiSelect,
            isSelected: isSelected,
            disabled: item.disabled
          });
        }
      }))));
    }
  }]);
  return OptionsList;
}(_react.PureComponent);

exports.default = OptionsList;
OptionsList.displayName = "OptionsList";
(0, _defineProperty2.default)(OptionsList, "propTypes", {
  options: _propTypes.default.arrayOf(_OptionShapePropType.default),
  close: _propTypes.default.func,
  height: _propTypes.default.number,
  width: _propTypes.default.number,

  /**
   * When true, multi select is accounted for.
   */
  isMultiSelect: _propTypes.default.bool,

  /**
   * This holds the values of the options
   */
  selected: _propTypes.default.arrayOf(_propTypes.default.string),
  onSelect: _propTypes.default.func,
  onDeselect: _propTypes.default.func,
  onFilterChange: _propTypes.default.func,
  hasFilter: _propTypes.default.bool,
  optionSize: _propTypes.default.number,
  renderItem: _propTypes.default.func,
  placeholder: _propTypes.default.string,
  optionsFilter: _propTypes.default.func,
  defaultSearchValue: _propTypes.default.string
});
(0, _defineProperty2.default)(OptionsList, "defaultProps", {
  options: [],

  /**
   * Including border bottom
   * For some reason passing height to TableRow doesn't work
   * TODO: fix hacky solution
   */
  optionSize: 33,
  onSelect: function onSelect() {},
  onDeselect: function onDeselect() {},
  onFilterChange: function onFilterChange() {},
  selected: [],
  renderItem: itemRenderer,
  optionsFilter: fuzzyFilter,
  placeholder: 'Filter...',
  defaultSearchValue: ''
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zZWxlY3QtbWVudS9zcmMvT3B0aW9uc0xpc3QuanMiXSwibmFtZXMiOlsiZnV6enlGaWx0ZXIiLCJvcHRpb25zIiwiaW5wdXQiLCJmdXp6YWxkcmluIiwiZmlsdGVyIiwiaXRlbVJlbmRlcmVyIiwicHJvcHMiLCJPcHRpb25zTGlzdCIsImNvbnRleHQiLCJpdGVtIiwic2VsZWN0ZWQiLCJzdGF0ZSIsIkJvb2xlYW4iLCJmaW5kIiwic2VsZWN0ZWRJdGVtIiwidmFsdWUiLCJvcHRpb25zRmlsdGVyIiwic2VhcmNoVmFsdWUiLCJ0cmltIiwibWFwIiwibGFiZWxJbkxpc3QiLCJsYWJlbCIsIm5hbWUiLCJnZXRGaWx0ZXJlZE9wdGlvbnMiLCJmaW5kSW5kZXgiLCJvcHRpb24iLCJsZW5ndGgiLCJlIiwia2V5Q29kZSIsImhhbmRsZUFycm93VXAiLCJoYW5kbGVBcnJvd0Rvd24iLCJoYW5kbGVFbnRlciIsIm9uU2VsZWN0IiwibmV4dEluZGV4IiwiZ2V0Q3VycmVudEluZGV4IiwiaXNTZWxlY3RlZCIsImNsb3NlIiwic2V0U3RhdGUiLCJvbkZpbHRlckNoYW5nZSIsIm9uRGVzZWxlY3QiLCJyZWYiLCJzZWFyY2hSZWYiLCJkZWZhdWx0U2VhcmNoVmFsdWUiLCJoYXNGaWx0ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJxdWVyeVNlbGVjdG9yIiwiZm9jdXMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlS2V5RG93biIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwcmV2UHJvcHMiLCJzZWFyY2giLCJvcmlnaW5hbE9wdGlvbnMiLCJ3aWR0aCIsImhlaWdodCIsIm9wdGlvblNpemUiLCJyZW5kZXJJdGVtIiwicGxhY2Vob2xkZXIiLCJpc011bHRpU2VsZWN0IiwibGlzdEhlaWdodCIsImN1cnJlbnRJbmRleCIsInNjcm9sbFRvSW5kZXgiLCJoYW5kbGVDaGFuZ2UiLCJhc3NpZ25TZWFyY2hSZWYiLCJpbmRleCIsInN0eWxlIiwia2V5IiwiaGFuZGxlU2VsZWN0IiwiaGFuZGxlRGVzZWxlY3QiLCJpc1NlbGVjdGFibGUiLCJkaXNhYmxlZCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJhcnJheU9mIiwiT3B0aW9uU2hhcGVQcm9wVHlwZSIsImZ1bmMiLCJudW1iZXIiLCJib29sIiwic3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFDQyxPQUFELEVBQVVDLEtBQVY7QUFBQSxTQUFvQkMsd0JBQVdDLE1BQVgsQ0FBa0JILE9BQWxCLEVBQTJCQyxLQUEzQixDQUFwQjtBQUFBLENBQXBCO0FBRUE7Ozs7OztBQUlBLElBQU1HLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUFDLEtBQUs7QUFBQSxTQUFJLDZCQUFDLGVBQUQsRUFBWUEsS0FBWixDQUFKO0FBQUEsQ0FBMUI7O0FBQU1ELFk7O0lBRWVFLFc7Ozs7O0FBNkNuQix1QkFBWUQsS0FBWixFQUFtQkUsT0FBbkIsRUFBNEI7QUFBQTs7QUFBQTtBQUMxQixpSEFBTUYsS0FBTixFQUFhRSxPQUFiO0FBRDBCLG1JQW9DZixVQUFBQyxJQUFJLEVBQUk7QUFBQSxVQUNYQyxRQURXLEdBQ0UsTUFBS0MsS0FEUCxDQUNYRCxRQURXO0FBR25CLGFBQU9FLE9BQU8sQ0FBQ0YsUUFBUSxDQUFDRyxJQUFULENBQWMsVUFBQUMsWUFBWTtBQUFBLGVBQUlBLFlBQVksS0FBS0wsSUFBSSxDQUFDTSxLQUExQjtBQUFBLE9BQTFCLENBQUQsQ0FBZDtBQUNELEtBeEMyQjtBQUFBLCtIQTBDbkIsVUFBQWQsT0FBTyxFQUFJO0FBQUEsVUFDVmUsYUFEVSxHQUNRLE1BQUtWLEtBRGIsQ0FDVlUsYUFEVTtBQUFBLFVBRVZDLFdBRlUsR0FFTSxNQUFLTixLQUZYLENBRVZNLFdBRlU7QUFJ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QUFPLEVBQUUsRUFEVzs7QUFFcEI7Ozs7O0FBS0F1RCxFQUFBQSxVQUFVLEVBQUUsRUFQUTtBQVFwQnhCLEVBQUFBLFFBQVEsRUFBRSxvQkFBTSxDQUFFLENBUkU7QUFTcEJPLEVBQUFBLFVBQVUsRUFBRSxzQkFBTSxDQUFFLENBVEE7QUFVcEJELEVBQUFBLGNBQWMsRUFBRSwwQkFBTSxDQUFFLENBVko7QUFXcEI1QixFQUFBQSxRQUFRLEVBQUUsRUFYVTtBQVlwQitDLEVBQUFBLFVBQVUsRUFBRXBELFlBWlE7QUFhcEJXLEVBQUFBLGFBQWEsRUFBRWhCLFdBYks7QUFjcEIwRCxFQUFBQSxXQUFXLEVBQUUsV0FkTztBQWVwQmhCLEVBQUFBLGtCQUFrQixFQUFFO0FBZkEsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgZnV6emFsZHJpbiBmcm9tICdmdXp6YWxkcmluLXBsdXMnXG5pbXBvcnQgVmlydHVhbExpc3QgZnJvbSAncmVhY3QtdGlueS12aXJ0dWFsLWxpc3QnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IHsgVGFibGVIZWFkLCBTZWFyY2hUYWJsZUhlYWRlckNlbGwgfSBmcm9tICcuLi8uLi90YWJsZSdcbmltcG9ydCBPcHRpb25TaGFwZVByb3BUeXBlIGZyb20gJy4vT3B0aW9uU2hhcGVQcm9wVHlwZSdcbmltcG9ydCBPcHRpb24gZnJvbSAnLi9PcHRpb24nXG5cbi8qKlxuICogRnV6emFsZHJpbi1wbHVzIGlzIHRoZSBkZWZhdWx0IGZpbHRlciwgYnV0IHlvdSBjYW4gdXNlIHlvdXIgb3duXG4gKiBhcyBsb25nIGFzIHRoZXkgZm9sbG93IHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogQHBhcmFtIG9wdGlvbnMgPEFycmF5W1N0cmluZ10+IC0gWydsYWJlbCcsICdsYWJlbDInLCAuLi5dXG4gKiBAcGFyYW0gaW5wdXQgPFN0cmluZz5cbiAqL1xuY29uc3QgZnV6enlGaWx0ZXIgPSAob3B0aW9ucywgaW5wdXQpID0+IGZ1enphbGRyaW4uZmlsdGVyKG9wdGlvbnMsIGlucHV0KVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgaXRlbSByZW5kZXJlciBvZiBvcHRpb25zXG4gKiB5b3UgY2FuIHBhc3MgY3VzdG9tIHJlbmRlcmVycyBhcyBsb25nIGFzIHRoZXkgd29yayB0aGUgc2FtZSBhcyB0aGUgT3B0aW9uXG4gKi9cbmNvbnN0IGl0ZW1SZW5kZXJlciA9IHByb3BzID0+IDxPcHRpb24gey4uLnByb3BzfSAvPlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zTGlzdCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5hcnJheU9mKE9wdGlvblNoYXBlUHJvcFR5cGUpLFxuICAgIGNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG11bHRpIHNlbGVjdCBpcyBhY2NvdW50ZWQgZm9yLlxuICAgICAqL1xuICAgIGlzTXVsdGlTZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBob2xkcyB0aGUgdmFsdWVzIG9mIHRoZSBvcHRpb25zXG4gICAgICovXG4gICAgc2VsZWN0ZWQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlc2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZpbHRlckNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGFzRmlsdGVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvcHRpb25TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJlbmRlckl0ZW06IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9wdGlvbnNGaWx0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRlZmF1bHRTZWFyY2hWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBvcHRpb25zOiBbXSxcbiAgICAvKipcbiAgICAgKiBJbmNsdWRpbmcgYm9yZGVyIGJvdHRvbVxuICAgICAqIEZvciBzb21lIHJlYXNvbiBwYXNzaW5nIGhlaWdodCB0byBUYWJsZVJvdyBkb2Vzbid0IHdvcmtcbiAgICAgKiBUT0RPOiBmaXggaGFja3kgc29sdXRpb25cbiAgICAgKi9cbiAgICBvcHRpb25TaXplOiAzMyxcbiAgICBvblNlbGVjdDogKCkgPT4ge30sXG4gICAgb25EZXNlbGVjdDogKCkgPT4ge30sXG4gICAgb25GaWx0ZXJDaGFuZ2U6ICgpID0+IHt9LFxuICAgIHNlbGVjdGVkOiBbXSxcbiAgICByZW5kZXJJdGVtOiBpdGVtUmVuZGVyZXIsXG4gICAgb3B0aW9uc0ZpbHRlcjogZnV6enlGaWx0ZXIsXG4gICAgcGxhY2Vob2xkZXI6ICdGaWx0ZXIuLi4nLFxuICAgIGRlZmF1bHRTZWFyY2hWYWx1ZTogJydcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc2VhcmNoVmFsdWU6IHByb3BzLmRlZmF1bHRTZWFyY2hWYWx1ZSxcbiAgICAgIHNlbGVjdGVkOiBwcm9wcy5zZWxlY3RlZFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgaGFzRmlsdGVyIH0gPSB0aGlzLnByb3BzXG4gICAgaWYgKCFoYXNGaWx0ZXIpIHJldHVyblxuICAgIC8qKlxuICAgICAqIEhhY2t5IHNvbHV0aW9uIGZvciBicm9rZW4gYXV0b0ZvY3VzXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnRpby9ldmVyZ3JlZW4vaXNzdWVzLzkwXG4gICAgICovXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoUmVmLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuZm9jdXMoKVxuICAgIH0pXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bilcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMuc2VsZWN0ZWQgIT09IHRoaXMucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaWQtdXBkYXRlLXNldC1zdGF0ZVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkOiB0aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzU2VsZWN0ZWQgPSBpdGVtID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gQm9vbGVhbihzZWxlY3RlZC5maW5kKHNlbGVjdGVkSXRlbSA9PiBzZWxlY3RlZEl0ZW0gPT09IGl0ZW0udmFsdWUpKVxuICB9XG5cbiAgc2VhcmNoID0gb3B0aW9ucyA9PiB7XG4gICAgY29uc3QgeyBvcHRpb25zRmlsdGVyIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBzZWFyY2hWYWx1ZSB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgcmV0dXJuIHNlYXJjaFZhbHVlLnRyaW0oKSA9PT0gJydcbiAgICAgID8gb3B0aW9ucyAvLyBSZXR1cm4gaWYgbm8gc2VhcmNoIHF1ZXJ5XG4gICAgICA6IG9wdGlvbnNGaWx0ZXIoXG4gICAgICAgICAgb3B0aW9ucy5tYXAoaXRlbSA9PiBpdGVtLmxhYmVsSW5MaXN0IHx8IGl0ZW0ubGFiZWwpLFxuICAgICAgICAgIHNlYXJjaFZhbHVlXG4gICAgICAgICkubWFwKG5hbWUgPT5cbiAgICAgICAgICBvcHRpb25zLmZpbmQoaXRlbSA9PiBpdGVtLmxhYmVsSW5MaXN0ID09PSBuYW1lIHx8IGl0ZW0ubGFiZWwgPT09IG5hbWUpXG4gICAgICAgIClcbiAgfVxuXG4gIGdldEN1cnJlbnRJbmRleCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGVkIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RmlsdGVyZWRPcHRpb25zKClcblxuICAgIHJldHVybiBvcHRpb25zLmZpbmRJbmRleChcbiAgICAgIG9wdGlvbiA9PiBvcHRpb24udmFsdWUgPT09IHNlbGVjdGVkW3NlbGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgKVxuICB9XG5cbiAgZ2V0RmlsdGVyZWRPcHRpb25zKCkge1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoKG9wdGlvbnMpXG4gIH1cblxuICBoYW5kbGVLZXlEb3duID0gZSA9PiB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHRoaXMuaGFuZGxlQXJyb3dVcCgpXG4gICAgfVxuXG4gICAgaWYgKGUua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgIHRoaXMuaGFuZGxlQXJyb3dEb3duKClcbiAgICB9XG5cbiAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5oYW5kbGVFbnRlcigpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQXJyb3dVcCA9ICgpID0+IHtcbiAgICBjb25zdCB7IG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RmlsdGVyZWRPcHRpb25zKClcblxuICAgIGxldCBuZXh0SW5kZXggPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpIC0gMVxuXG4gICAgaWYgKG5leHRJbmRleCA8IDApIHtcbiAgICAgIG5leHRJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMVxuICAgIH1cblxuICAgIG9uU2VsZWN0KG9wdGlvbnNbbmV4dEluZGV4XSlcbiAgfVxuXG4gIGhhbmRsZUFycm93RG93biA9ICgpID0+IHtcbiAgICBjb25zdCB7IG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0RmlsdGVyZWRPcHRpb25zKClcblxuICAgIGxldCBuZXh0SW5kZXggPSB0aGlzLmdldEN1cnJlbnRJbmRleCgpICsgMVxuXG4gICAgaWYgKG5leHRJbmRleCA9PT0gb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG5leHRJbmRleCA9IDBcbiAgICB9XG5cbiAgICBvblNlbGVjdChvcHRpb25zW25leHRJbmRleF0pXG4gIH1cblxuICBoYW5kbGVFbnRlciA9ICgpID0+IHtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGhpcy5nZXRDdXJyZW50SW5kZXgoKSAhPT0gLTFcblxuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnByb3BzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgPSBzZWFyY2hWYWx1ZSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzZWFyY2hWYWx1ZVxuICAgIH0pXG4gICAgdGhpcy5wcm9wcy5vbkZpbHRlckNoYW5nZShzZWFyY2hWYWx1ZSlcbiAgfVxuXG4gIGhhbmRsZVNlbGVjdCA9IGl0ZW0gPT4ge1xuICAgIHRoaXMucHJvcHMub25TZWxlY3QoaXRlbSlcbiAgfVxuXG4gIGhhbmRsZURlc2VsZWN0ID0gaXRlbSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkRlc2VsZWN0KGl0ZW0pXG4gIH1cblxuICBhc3NpZ25TZWFyY2hSZWYgPSByZWYgPT4ge1xuICAgIHRoaXMuc2VhcmNoUmVmID0gcmVmXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0aW9uczogb3JpZ2luYWxPcHRpb25zLFxuICAgICAgY2xvc2UsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG9uU2VsZWN0LFxuICAgICAgb25EZXNlbGVjdCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgaGFzRmlsdGVyLFxuICAgICAgb3B0aW9uU2l6ZSxcbiAgICAgIHJlbmRlckl0ZW0sXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIG9wdGlvbnNGaWx0ZXIsXG4gICAgICBpc011bHRpU2VsZWN0LFxuICAgICAgZGVmYXVsdFNlYXJjaFZhbHVlLFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnNlYXJjaChvcmlnaW5hbE9wdGlvbnMpXG4gICAgY29uc3QgbGlzdEhlaWdodCA9IGhlaWdodCAtIChoYXNGaWx0ZXIgPyAzMiA6IDApXG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5nZXRDdXJyZW50SW5kZXgoKVxuICAgIGNvbnN0IHNjcm9sbFRvSW5kZXggPSBjdXJyZW50SW5kZXggPT09IC0xID8gMCA6IGN1cnJlbnRJbmRleFxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxQYW5lXG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgZmxleERpcmVjdGlvbj1cImNvbHVtblwiXG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgID5cbiAgICAgICAge2hhc0ZpbHRlciAmJiAoXG4gICAgICAgICAgPFRhYmxlSGVhZD5cbiAgICAgICAgICAgIDxTZWFyY2hUYWJsZUhlYWRlckNlbGxcbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgICBpbm5lclJlZj17dGhpcy5hc3NpZ25TZWFyY2hSZWZ9XG4gICAgICAgICAgICAgIGJvcmRlclJpZ2h0PXtudWxsfVxuICAgICAgICAgICAgICBoZWlnaHQ9ezMyfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1RhYmxlSGVhZD5cbiAgICAgICAgKX1cbiAgICAgICAgPFBhbmUgZmxleD17MX0+XG4gICAgICAgICAgPFZpcnR1YWxMaXN0XG4gICAgICAgICAgICBoZWlnaHQ9e2xpc3RIZWlnaHR9XG4gICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgaXRlbVNpemU9e29wdGlvblNpemV9XG4gICAgICAgICAgICBpdGVtQ291bnQ9e29wdGlvbnMubGVuZ3RofVxuICAgICAgICAgICAgb3ZlcnNjYW5Db3VudD17MjB9XG4gICAgICAgICAgICBzY3JvbGxUb0FsaWdubWVudD1cImF1dG9cIlxuICAgICAgICAgICAgey4uLihzY3JvbGxUb0luZGV4XG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9JbmRleFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB7fSl9XG4gICAgICAgICAgICByZW5kZXJJdGVtPXsoeyBpbmRleCwgc3R5bGUgfSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtID0gb3B0aW9uc1tpbmRleF1cbiAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHRoaXMuaXNTZWxlY3RlZChpdGVtKVxuICAgICAgICAgICAgICByZXR1cm4gcmVuZGVySXRlbSh7XG4gICAgICAgICAgICAgICAga2V5OiBpdGVtLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLFxuICAgICAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9uU2l6ZSxcbiAgICAgICAgICAgICAgICBvblNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVTZWxlY3QoaXRlbSksXG4gICAgICAgICAgICAgICAgb25EZXNlbGVjdDogKCkgPT4gdGhpcy5oYW5kbGVEZXNlbGVjdChpdGVtKSxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGU6ICFpc1NlbGVjdGVkIHx8IGlzTXVsdGlTZWxlY3QsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXRlbS5kaXNhYmxlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L1BhbmU+XG4gICAgICA8L1BhbmU+XG4gICAgKVxuICB9XG59XG4iXX0=