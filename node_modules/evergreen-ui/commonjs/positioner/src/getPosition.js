"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFittedPosition;

var _constants = require("../../constants");

/**
 * Function to create a Rect.
 * @param {Object} dimensions
 * @param {Number} dimensions.width
 * @param {Number} dimensions.height
 * @param {Object} position
 * @param {Number} position.left
 * @param {Number} position.top
 * @return {Object} Rect { width, height, left, top, right, bottom }
 */
var makeRect = function makeRect(_ref, _ref2) {
  var width = _ref.width,
      height = _ref.height;
  var left = _ref2.left,
      top = _ref2.top;
  var ceiledLeft = Math.ceil(left);
  var ceiledTop = Math.ceil(top);
  return {
    width: width,
    height: height,
    left: ceiledLeft,
    top: ceiledTop,
    right: ceiledLeft + width,
    bottom: ceiledTop + height
  };
};
/**
 * Function to flip a position upside down.
 * @param {Position} position
 * @return {Position} flipped position
 */


var flipHorizontal = function flipHorizontal(position) {
  switch (position) {
    case _constants.Position.TOP_LEFT:
      return _constants.Position.BOTTOM_LEFT;

    case _constants.Position.TOP:
    default:
      return _constants.Position.BOTTOM;

    case _constants.Position.TOP_RIGHT:
      return _constants.Position.BOTTOM_RIGHT;

    case _constants.Position.BOTTOM_LEFT:
      return _constants.Position.TOP_LEFT;

    case _constants.Position.BOTTOM:
      return _constants.Position.TOP;

    case _constants.Position.BOTTOM_RIGHT:
      return _constants.Position.TOP_RIGHT;
  }
};
/**
 * Function that returns if position is aligned on top.
 * @param {Position} position
 * @return {Boolean}
 */


var isAlignedOnTop = function isAlignedOnTop(position) {
  switch (position) {
    case _constants.Position.TOP_LEFT:
    case _constants.Position.TOP:
    case _constants.Position.TOP_RIGHT:
      return true;

    default:
      return false;
  }
};
/**
 * Function that returns if position is aligned left or right.
 * @param {Position} position
 * @return {Boolean}
 */


var isAlignedHorizontal = function isAlignedHorizontal(position) {
  switch (position) {
    case _constants.Position.LEFT:
    case _constants.Position.RIGHT:
      return true;

    default:
      return false;
  }
};
/**
 * Function that returns if a rect fits on bottom.
 * @param {Rect} rect
 * @param {Object} viewport
 * @param {Number} viewportOffset
 * @return {Boolean}
 */


var getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {
  return rect.bottom < viewport.height - viewportOffset;
};
/**
 * Function that returns if a rect fits on top.
 * @param {Rect} rect
 * @param {Number} viewportOffset
 * @return {Boolean}
 */


var getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {
  return rect.top > viewportOffset;
};
/**
 * Function that returns if a rect fits on right.
 * @param {Rect} rect
 * @param {Object} viewport
 * @param {Number} viewportOffset
 * @return {Boolean}
 */


var getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {
  return rect.right < viewport.width - viewportOffset;
};
/**
 * Function that returns if a rect fits on left.
 * @param {Rect} rect
 * @param {Number} viewportOffset
 * @return {Boolean}
 */


var getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {
  return rect.left > viewportOffset;
};
/**
 * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
 * Function that returns the CSS `tranform-origin` property.
 * @param {Rect} rect
 * @param {Position} position
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Number} targetCenter - center of the target.
 * @return {String} transform origin
 */


var getTransformOrigin = function getTransformOrigin(_ref3) {
  var rect = _ref3.rect,
      position = _ref3.position,
      dimensions = _ref3.dimensions,
      targetCenter = _ref3.targetCenter;
  var centerY = Math.round(targetCenter - rect.top);

  if (position === _constants.Position.LEFT) {
    /* Syntax: x-offset | y-offset */
    return "".concat(dimensions.width, "px ").concat(centerY, "px");
  }

  if (position === _constants.Position.RIGHT) {
    /* Syntax: x-offset | y-offset */
    return "0px ".concat(centerY, "px");
  }

  var centerX = Math.round(targetCenter - rect.left);

  if (isAlignedOnTop(position)) {
    /* Syntax: x-offset | y-offset */
    return "".concat(centerX, "px ").concat(dimensions.height, "px ");
  }
  /* Syntax: x-offset | y-offset */


  return "".concat(centerX, "px 0px ");
};
/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { x: Number, y: Number }
 */


function getFittedPosition(_ref4) {
  var position = _ref4.position,
      dimensions = _ref4.dimensions,
      targetRect = _ref4.targetRect,
      targetOffset = _ref4.targetOffset,
      viewport = _ref4.viewport,
      _ref4$viewportOffset = _ref4.viewportOffset,
      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;

  var _getPosition = getPosition({
    position: position,
    dimensions: dimensions,
    targetRect: targetRect,
    targetOffset: targetOffset,
    viewport: viewport,
    viewportOffset: viewportOffset
  }),
      rect = _getPosition.rect,
      finalPosition = _getPosition.position; // Push rect to the right if overflowing on the left side of the viewport.


  if (rect.left < viewportOffset) {
    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));
    rect.left = Math.ceil(viewportOffset);
  } // Push rect to the left if overflowing on the right side of the viewport.


  if (rect.right > viewport.width - viewportOffset) {
    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));
    rect.left -= delta;
    rect.right -= delta;
  } // Push rect down if overflowing on the top side of the viewport.


  if (rect.top < viewportOffset) {
    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));
    rect.bottom = Math.ceil(viewportOffset);
  } // Push rect up if overflowing on the bottom side of the viewport.


  if (rect.bottom > viewport.height - viewportOffset) {
    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));

    rect.top -= _delta;
    rect.right -= _delta;
  }

  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;
  var transformOrigin = getTransformOrigin({
    rect: rect,
    position: finalPosition,
    dimensions: dimensions,
    targetCenter: targetCenter
  });
  return {
    rect: rect,
    position: finalPosition,
    transformOrigin: transformOrigin
  };
}
/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Position} position — the position the positioner should be on.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} viewport - the width and height of the viewport.
 * @param {Object} viewportOffset - offset from the viewport.
 * @return {Object} - { rect: Rect, position: Position }
 */


function getPosition(_ref5) {
  var position = _ref5.position,
      dimensions = _ref5.dimensions,
      targetRect = _ref5.targetRect,
      targetOffset = _ref5.targetOffset,
      viewport = _ref5.viewport,
      _ref5$viewportOffset = _ref5.viewportOffset,
      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;
  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions

  if (isHorizontal) {
    var leftRect = getRect({
      position: _constants.Position.LEFT,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    var rightRect = getRect({
      position: _constants.Position.RIGHT,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);
    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);

    if (position === _constants.Position.LEFT) {
      if (fitsOnLeft) {
        return {
          position: position,
          rect: leftRect
        };
      }

      if (fitsOnRight) {
        return {
          position: _constants.Position.RIGHT,
          rect: rightRect
        };
      }
    }

    if (position === _constants.Position.RIGHT) {
      if (fitsOnRight) {
        return {
          position: position,
          rect: rightRect
        };
      }

      if (fitsOnLeft) {
        return {
          position: _constants.Position.LEFT,
          rect: leftRect
        };
      }
    } // Default to using the position with the most space


    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);
    var spaceLeft = Math.abs(leftRect.left - viewportOffset);

    if (spaceRight < spaceLeft) {
      return {
        position: _constants.Position.RIGHT,
        rect: rightRect
      };
    }

    return {
      position: _constants.Position.LEFT,
      rect: leftRect
    };
  }

  var positionIsAlignedOnTop = isAlignedOnTop(position);
  var topRect;
  var bottomRect;

  if (positionIsAlignedOnTop) {
    topRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  } else {
    topRect = getRect({
      position: flipHorizontal(position),
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
    bottomRect = getRect({
      position: position,
      dimensions: dimensions,
      targetRect: targetRect,
      targetOffset: targetOffset
    });
  }

  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);
  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);

  if (positionIsAlignedOnTop) {
    if (topRectFitsOnTop) {
      return {
        position: position,
        rect: topRect
      };
    }

    if (bottomRectFitsOnBottom) {
      return {
        position: flipHorizontal(position),
        rect: bottomRect
      };
    }
  }

  if (!positionIsAlignedOnTop) {
    if (bottomRectFitsOnBottom) {
      return {
        position: position,
        rect: bottomRect
      };
    }

    if (topRectFitsOnTop) {
      return {
        position: flipHorizontal(position),
        rect: topRect
      };
    }
  } // Default to most spacious if there is no fit.


  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);
  var spaceTop = Math.abs(topRect.top - viewportOffset);

  if (spaceBottom < spaceTop) {
    return {
      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,
      rect: bottomRect
    };
  }

  return {
    position: positionIsAlignedOnTop ? position : flipHorizontal(position),
    rect: topRect
  };
}
/**
 * Function that takes in numbers and position and gives the final coords.
 * @param {Object} position - the width and height of the viewport.
 * @param {Number} targetOffset - offset from the target.
 * @param {Object} dimensions — the dimensions of the positioner.
 * @param {Object} targetRect — the rect of the target.
 * @return {Object} - { x: Number, y: Number }
 */


function getRect(_ref6) {
  var position = _ref6.position,
      targetOffset = _ref6.targetOffset,
      dimensions = _ref6.dimensions,
      targetRect = _ref6.targetRect;
  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;
  var alignedTopY = targetRect.top - dimensions.height - targetOffset;
  var alignedBottomY = targetRect.bottom + targetOffset;
  var alignedRightX = targetRect.right - dimensions.width;
  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;

  switch (position) {
    case _constants.Position.LEFT:
      return makeRect(dimensions, {
        left: targetRect.left - dimensions.width - targetOffset,
        top: alignedLeftRightY
      });

    case _constants.Position.RIGHT:
      return makeRect(dimensions, {
        left: targetRect.right + targetOffset,
        top: alignedLeftRightY
      });

    case _constants.Position.TOP:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedTopY
      });

    case _constants.Position.TOP_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedTopY
      });

    case _constants.Position.TOP_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedTopY
      });

    default:
    case _constants.Position.BOTTOM:
      return makeRect(dimensions, {
        left: leftRect,
        top: alignedBottomY
      });

    case _constants.Position.BOTTOM_LEFT:
      return makeRect(dimensions, {
        left: targetRect.left,
        top: alignedBottomY
      });

    case _constants.Position.BOTTOM_RIGHT:
      return makeRect(dimensions, {
        left: alignedRightX,
        top: alignedBottomY
      });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9nZXRQb3NpdGlvbi5qcyJdLCJuYW1lcyI6WyJtYWtlUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwibGVmdCIsInRvcCIsImNlaWxlZExlZnQiLCJNYXRoIiwiY2VpbCIsImNlaWxlZFRvcCIsInJpZ2h0IiwiYm90dG9tIiwiZmxpcEhvcml6b250YWwiLCJwb3NpdGlvbiIsIlBvc2l0aW9uIiwiVE9QX0xFRlQiLCJCT1RUT01fTEVGVCIsIlRPUCIsIkJPVFRPTSIsIlRPUF9SSUdIVCIsIkJPVFRPTV9SSUdIVCIsImlzQWxpZ25lZE9uVG9wIiwiaXNBbGlnbmVkSG9yaXpvbnRhbCIsIkxFRlQiLCJSSUdIVCIsImdldEZpdHNPbkJvdHRvbSIsInJlY3QiLCJ2aWV3cG9ydCIsInZpZXdwb3J0T2Zmc2V0IiwiZ2V0Rml0c09uVG9wIiwiZ2V0Rml0c09uUmlnaHQiLCJnZXRGaXRzT25MZWZ0IiwiZ2V0VHJhbnNmb3JtT3JpZ2luIiwiZGltZW5zaW9ucyIsInRhcmdldENlbnRlciIsImNlbnRlclkiLCJyb3VuZCIsImNlbnRlclgiLCJnZXRGaXR0ZWRQb3NpdGlvbiIsInRhcmdldFJlY3QiLCJ0YXJnZXRPZmZzZXQiLCJnZXRQb3NpdGlvbiIsImZpbmFsUG9zaXRpb24iLCJhYnMiLCJkZWx0YSIsInRyYW5zZm9ybU9yaWdpbiIsImlzSG9yaXpvbnRhbCIsImxlZnRSZWN0IiwiZ2V0UmVjdCIsInJpZ2h0UmVjdCIsImZpdHNPbkxlZnQiLCJmaXRzT25SaWdodCIsInNwYWNlUmlnaHQiLCJzcGFjZUxlZnQiLCJwb3NpdGlvbklzQWxpZ25lZE9uVG9wIiwidG9wUmVjdCIsImJvdHRvbVJlY3QiLCJ0b3BSZWN0Rml0c09uVG9wIiwiYm90dG9tUmVjdEZpdHNPbkJvdHRvbSIsInNwYWNlQm90dG9tIiwic3BhY2VUb3AiLCJhbGlnbmVkVG9wWSIsImFsaWduZWRCb3R0b21ZIiwiYWxpZ25lZFJpZ2h0WCIsImFsaWduZWRMZWZ0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QUFhO0FBQzFCN0IsUUFBQUEsSUFBSSxFQUFFMkQsYUFEb0I7QUFFMUIxRCxRQUFBQSxHQUFHLEVBQUV5RDtBQUZxQixPQUFiLENBQWY7QUF0Q0o7QUEyQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cydcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjcmVhdGUgYSBSZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaW1lbnNpb25zLndpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gZGltZW5zaW9ucy5oZWlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uLmxlZnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbi50b3BcbiAqIEByZXR1cm4ge09iamVjdH0gUmVjdCB7IHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSB9XG4gKi9cbmNvbnN0IG1ha2VSZWN0ID0gKHsgd2lkdGgsIGhlaWdodCB9LCB7IGxlZnQsIHRvcCB9KSA9PiB7XG4gIGNvbnN0IGNlaWxlZExlZnQgPSBNYXRoLmNlaWwobGVmdClcbiAgY29uc3QgY2VpbGVkVG9wID0gTWF0aC5jZWlsKHRvcClcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGVmdDogY2VpbGVkTGVmdCxcbiAgICB0b3A6IGNlaWxlZFRvcCxcbiAgICByaWdodDogY2VpbGVkTGVmdCArIHdpZHRoLFxuICAgIGJvdHRvbTogY2VpbGVkVG9wICsgaGVpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBmbGlwIGEgcG9zaXRpb24gdXBzaWRlIGRvd24uXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvblxuICogQHJldHVybiB7UG9zaXRpb259IGZsaXBwZWQgcG9zaXRpb25cbiAqL1xuY29uc3QgZmxpcEhvcml6b250YWwgPSBwb3NpdGlvbiA9PiB7XG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlIFBvc2l0aW9uLlRPUF9MRUZUOlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLkJPVFRPTV9MRUZUXG4gICAgY2FzZSBQb3NpdGlvbi5UT1A6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5CT1RUT01cbiAgICBjYXNlIFBvc2l0aW9uLlRPUF9SSUdIVDpcbiAgICAgIHJldHVybiBQb3NpdGlvbi5CT1RUT01fUklHSFRcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTV9MRUZUOlxuICAgICAgcmV0dXJuIFBvc2l0aW9uLlRPUF9MRUZUXG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT006XG4gICAgICByZXR1cm4gUG9zaXRpb24uVE9QXG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT01fUklHSFQ6XG4gICAgICByZXR1cm4gUG9zaXRpb24uVE9QX1JJR0hUXG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgaWYgcG9zaXRpb24gaXMgYWxpZ25lZCBvbiB0b3AuXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwb3NpdGlvblxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3QgaXNBbGlnbmVkT25Ub3AgPSBwb3NpdGlvbiA9PiB7XG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlIFBvc2l0aW9uLlRPUF9MRUZUOlxuICAgIGNhc2UgUG9zaXRpb24uVE9QOlxuICAgIGNhc2UgUG9zaXRpb24uVE9QX1JJR0hUOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgaWYgcG9zaXRpb24gaXMgYWxpZ25lZCBsZWZ0IG9yIHJpZ2h0LlxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzQWxpZ25lZEhvcml6b250YWwgPSBwb3NpdGlvbiA9PiB7XG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlIFBvc2l0aW9uLkxFRlQ6XG4gICAgY2FzZSBQb3NpdGlvbi5SSUdIVDpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGlmIGEgcmVjdCBmaXRzIG9uIGJvdHRvbS5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRPZmZzZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGdldEZpdHNPbkJvdHRvbSA9IChyZWN0LCB2aWV3cG9ydCwgdmlld3BvcnRPZmZzZXQpID0+IHtcbiAgcmV0dXJuIHJlY3QuYm90dG9tIDwgdmlld3BvcnQuaGVpZ2h0IC0gdmlld3BvcnRPZmZzZXRcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgaWYgYSByZWN0IGZpdHMgb24gdG9wLlxuICogQHBhcmFtIHtSZWN0fSByZWN0XG4gKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRPZmZzZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGdldEZpdHNPblRvcCA9IChyZWN0LCB2aWV3cG9ydE9mZnNldCkgPT4ge1xuICByZXR1cm4gcmVjdC50b3AgPiB2aWV3cG9ydE9mZnNldFxufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpZiBhIHJlY3QgZml0cyBvbiByaWdodC5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRPZmZzZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGdldEZpdHNPblJpZ2h0ID0gKHJlY3QsIHZpZXdwb3J0LCB2aWV3cG9ydE9mZnNldCkgPT4ge1xuICByZXR1cm4gcmVjdC5yaWdodCA8IHZpZXdwb3J0LndpZHRoIC0gdmlld3BvcnRPZmZzZXRcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgaWYgYSByZWN0IGZpdHMgb24gbGVmdC5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0T2Zmc2V0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBnZXRGaXRzT25MZWZ0ID0gKHJlY3QsIHZpZXdwb3J0T2Zmc2V0KSA9PiB7XG4gIHJldHVybiByZWN0LmxlZnQgPiB2aWV3cG9ydE9mZnNldFxufVxuXG4vKipcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0tb3JpZ2luXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIENTUyBgdHJhbmZvcm0tb3JpZ2luYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7UmVjdH0gcmVjdFxuICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zIOKAlCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcG9zaXRpb25lci5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRDZW50ZXIgLSBjZW50ZXIgb2YgdGhlIHRhcmdldC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdHJhbnNmb3JtIG9yaWdpblxuICovXG5jb25zdCBnZXRUcmFuc2Zvcm1PcmlnaW4gPSAoeyByZWN0LCBwb3NpdGlvbiwgZGltZW5zaW9ucywgdGFyZ2V0Q2VudGVyIH0pID0+IHtcbiAgY29uc3QgY2VudGVyWSA9IE1hdGgucm91bmQodGFyZ2V0Q2VudGVyIC0gcmVjdC50b3ApXG5cbiAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MRUZUKSB7XG4gICAgLyogU3ludGF4OiB4LW9mZnNldCB8IHktb2Zmc2V0ICovXG4gICAgcmV0dXJuIGAke2RpbWVuc2lvbnMud2lkdGh9cHggJHtjZW50ZXJZfXB4YFxuICB9XG5cbiAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SSUdIVCkge1xuICAgIC8qIFN5bnRheDogeC1vZmZzZXQgfCB5LW9mZnNldCAqL1xuICAgIHJldHVybiBgMHB4ICR7Y2VudGVyWX1weGBcbiAgfVxuXG4gIGNvbnN0IGNlbnRlclggPSBNYXRoLnJvdW5kKHRhcmdldENlbnRlciAtIHJlY3QubGVmdClcblxuICBpZiAoaXNBbGlnbmVkT25Ub3AocG9zaXRpb24pKSB7XG4gICAgLyogU3ludGF4OiB4LW9mZnNldCB8IHktb2Zmc2V0ICovXG4gICAgcmV0dXJuIGAke2NlbnRlclh9cHggJHtkaW1lbnNpb25zLmhlaWdodH1weCBgXG4gIH1cbiAgLyogU3ludGF4OiB4LW9mZnNldCB8IHktb2Zmc2V0ICovXG4gIHJldHVybiBgJHtjZW50ZXJYfXB4IDBweCBgXG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBudW1iZXJzIGFuZCBwb3NpdGlvbiBhbmQgZ2l2ZXMgdGhlIGZpbmFsIGNvb3Jkcy5cbiAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIOKAlCB0aGUgcG9zaXRpb24gdGhlIHBvc2l0aW9uZXIgc2hvdWxkIGJlIG9uLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMg4oCUIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwb3NpdGlvbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFJlY3Qg4oCUIHRoZSByZWN0IG9mIHRoZSB0YXJnZXQuXG4gKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0T2Zmc2V0IC0gb2Zmc2V0IGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydE9mZnNldCAtIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydC5cbiAqIEByZXR1cm4ge09iamVjdH0gLSB7IHg6IE51bWJlciwgeTogTnVtYmVyIH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Rml0dGVkUG9zaXRpb24oe1xuICBwb3NpdGlvbixcbiAgZGltZW5zaW9ucyxcbiAgdGFyZ2V0UmVjdCxcbiAgdGFyZ2V0T2Zmc2V0LFxuICB2aWV3cG9ydCxcbiAgdmlld3BvcnRPZmZzZXQgPSA4XG59KSB7XG4gIGNvbnN0IHsgcmVjdCwgcG9zaXRpb246IGZpbmFsUG9zaXRpb24gfSA9IGdldFBvc2l0aW9uKHtcbiAgICBwb3NpdGlvbixcbiAgICBkaW1lbnNpb25zLFxuICAgIHRhcmdldFJlY3QsXG4gICAgdGFyZ2V0T2Zmc2V0LFxuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdwb3J0T2Zmc2V0XG4gIH0pXG5cbiAgLy8gUHVzaCByZWN0IHRvIHRoZSByaWdodCBpZiBvdmVyZmxvd2luZyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB2aWV3cG9ydC5cbiAgaWYgKHJlY3QubGVmdCA8IHZpZXdwb3J0T2Zmc2V0KSB7XG4gICAgcmVjdC5yaWdodCArPSBNYXRoLmNlaWwoTWF0aC5hYnMocmVjdC5sZWZ0IC0gdmlld3BvcnRPZmZzZXQpKVxuICAgIHJlY3QubGVmdCA9IE1hdGguY2VpbCh2aWV3cG9ydE9mZnNldClcbiAgfVxuXG4gIC8vIFB1c2ggcmVjdCB0byB0aGUgbGVmdCBpZiBvdmVyZmxvd2luZyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gIGlmIChyZWN0LnJpZ2h0ID4gdmlld3BvcnQud2lkdGggLSB2aWV3cG9ydE9mZnNldCkge1xuICAgIGNvbnN0IGRlbHRhID0gTWF0aC5jZWlsKHJlY3QucmlnaHQgLSAodmlld3BvcnQud2lkdGggLSB2aWV3cG9ydE9mZnNldCkpXG4gICAgcmVjdC5sZWZ0IC09IGRlbHRhXG4gICAgcmVjdC5yaWdodCAtPSBkZWx0YVxuICB9XG5cbiAgLy8gUHVzaCByZWN0IGRvd24gaWYgb3ZlcmZsb3dpbmcgb24gdGhlIHRvcCBzaWRlIG9mIHRoZSB2aWV3cG9ydC5cbiAgaWYgKHJlY3QudG9wIDwgdmlld3BvcnRPZmZzZXQpIHtcbiAgICByZWN0LnRvcCArPSBNYXRoLmNlaWwoTWF0aC5hYnMocmVjdC50b3AgLSB2aWV3cG9ydE9mZnNldCkpXG4gICAgcmVjdC5ib3R0b20gPSBNYXRoLmNlaWwodmlld3BvcnRPZmZzZXQpXG4gIH1cblxuICAvLyBQdXNoIHJlY3QgdXAgaWYgb3ZlcmZsb3dpbmcgb24gdGhlIGJvdHRvbSBzaWRlIG9mIHRoZSB2aWV3cG9ydC5cbiAgaWYgKHJlY3QuYm90dG9tID4gdmlld3BvcnQuaGVpZ2h0IC0gdmlld3BvcnRPZmZzZXQpIHtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguY2VpbChyZWN0LmJvdHRvbSAtICh2aWV3cG9ydC5oZWlnaHQgLSB2aWV3cG9ydE9mZnNldCkpXG4gICAgcmVjdC50b3AgLT0gZGVsdGFcbiAgICByZWN0LnJpZ2h0IC09IGRlbHRhXG4gIH1cblxuICBjb25zdCB0YXJnZXRDZW50ZXIgPSBpc0FsaWduZWRIb3Jpem9udGFsKHBvc2l0aW9uKVxuICAgID8gdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodCAvIDJcbiAgICA6IHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGggLyAyXG5cbiAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luKHtcbiAgICByZWN0LFxuICAgIHBvc2l0aW9uOiBmaW5hbFBvc2l0aW9uLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdGFyZ2V0Q2VudGVyXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICByZWN0LFxuICAgIHBvc2l0aW9uOiBmaW5hbFBvc2l0aW9uLFxuICAgIHRyYW5zZm9ybU9yaWdpblxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBudW1iZXJzIGFuZCBwb3NpdGlvbiBhbmQgZ2l2ZXMgdGhlIGZpbmFsIGNvb3Jkcy5cbiAqIEBwYXJhbSB7UG9zaXRpb259IHBvc2l0aW9uIOKAlCB0aGUgcG9zaXRpb24gdGhlIHBvc2l0aW9uZXIgc2hvdWxkIGJlIG9uLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMg4oCUIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwb3NpdGlvbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFJlY3Qg4oCUIHRoZSByZWN0IG9mIHRoZSB0YXJnZXQuXG4gKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0T2Zmc2V0IC0gb2Zmc2V0IGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydCAtIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3cG9ydE9mZnNldCAtIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydC5cbiAqIEByZXR1cm4ge09iamVjdH0gLSB7IHJlY3Q6IFJlY3QsIHBvc2l0aW9uOiBQb3NpdGlvbiB9XG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKHtcbiAgcG9zaXRpb24sXG4gIGRpbWVuc2lvbnMsXG4gIHRhcmdldFJlY3QsXG4gIHRhcmdldE9mZnNldCxcbiAgdmlld3BvcnQsXG4gIHZpZXdwb3J0T2Zmc2V0ID0gOFxufSkge1xuICBjb25zdCBpc0hvcml6b250YWwgPSBpc0FsaWduZWRIb3Jpem9udGFsKHBvc2l0aW9uKVxuXG4gIC8vIEhhbmRsZSBsZWZ0IGFuZCByaWdodCBwb3NpdGlvbnNcbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIGNvbnN0IGxlZnRSZWN0ID0gZ2V0UmVjdCh7XG4gICAgICBwb3NpdGlvbjogUG9zaXRpb24uTEVGVCxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgdGFyZ2V0T2Zmc2V0XG4gICAgfSlcblxuICAgIGNvbnN0IHJpZ2h0UmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb246IFBvc2l0aW9uLlJJR0hULFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuXG4gICAgY29uc3QgZml0c09uTGVmdCA9IGdldEZpdHNPbkxlZnQobGVmdFJlY3QsIHZpZXdwb3J0T2Zmc2V0KVxuICAgIGNvbnN0IGZpdHNPblJpZ2h0ID0gZ2V0Rml0c09uUmlnaHQocmlnaHRSZWN0LCB2aWV3cG9ydCwgdmlld3BvcnRPZmZzZXQpXG5cbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxFRlQpIHtcbiAgICAgIGlmIChmaXRzT25MZWZ0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcmVjdDogbGVmdFJlY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpdHNPblJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zaXRpb246IFBvc2l0aW9uLlJJR0hULFxuICAgICAgICAgIHJlY3Q6IHJpZ2h0UmVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SSUdIVCkge1xuICAgICAgaWYgKGZpdHNPblJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcmVjdDogcmlnaHRSZWN0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaXRzT25MZWZ0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zaXRpb246IFBvc2l0aW9uLkxFRlQsXG4gICAgICAgICAgcmVjdDogbGVmdFJlY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gdXNpbmcgdGhlIHBvc2l0aW9uIHdpdGggdGhlIG1vc3Qgc3BhY2VcbiAgICBjb25zdCBzcGFjZVJpZ2h0ID0gTWF0aC5hYnMoXG4gICAgICB2aWV3cG9ydC53aWR0aCAtIHZpZXdwb3J0T2Zmc2V0IC0gcmlnaHRSZWN0LnJpZ2h0XG4gICAgKVxuICAgIGNvbnN0IHNwYWNlTGVmdCA9IE1hdGguYWJzKGxlZnRSZWN0LmxlZnQgLSB2aWV3cG9ydE9mZnNldClcblxuICAgIGlmIChzcGFjZVJpZ2h0IDwgc3BhY2VMZWZ0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogUG9zaXRpb24uUklHSFQsXG4gICAgICAgIHJlY3Q6IHJpZ2h0UmVjdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogUG9zaXRpb24uTEVGVCxcbiAgICAgIHJlY3Q6IGxlZnRSZWN0XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcG9zaXRpb25Jc0FsaWduZWRPblRvcCA9IGlzQWxpZ25lZE9uVG9wKHBvc2l0aW9uKVxuICBsZXQgdG9wUmVjdFxuICBsZXQgYm90dG9tUmVjdFxuXG4gIGlmIChwb3NpdGlvbklzQWxpZ25lZE9uVG9wKSB7XG4gICAgdG9wUmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgIHRhcmdldE9mZnNldFxuICAgIH0pXG4gICAgYm90dG9tUmVjdCA9IGdldFJlY3Qoe1xuICAgICAgcG9zaXRpb246IGZsaXBIb3Jpem9udGFsKHBvc2l0aW9uKSxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICB0YXJnZXRSZWN0LFxuICAgICAgdGFyZ2V0T2Zmc2V0XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0b3BSZWN0ID0gZ2V0UmVjdCh7XG4gICAgICBwb3NpdGlvbjogZmxpcEhvcml6b250YWwocG9zaXRpb24pLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuICAgIGJvdHRvbVJlY3QgPSBnZXRSZWN0KHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXRcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgdG9wUmVjdEZpdHNPblRvcCA9IGdldEZpdHNPblRvcCh0b3BSZWN0LCB2aWV3cG9ydE9mZnNldClcblxuICBjb25zdCBib3R0b21SZWN0Rml0c09uQm90dG9tID0gZ2V0Rml0c09uQm90dG9tKFxuICAgIGJvdHRvbVJlY3QsXG4gICAgdmlld3BvcnQsXG4gICAgdmlld3BvcnRPZmZzZXRcbiAgKVxuXG4gIGlmIChwb3NpdGlvbklzQWxpZ25lZE9uVG9wKSB7XG4gICAgaWYgKHRvcFJlY3RGaXRzT25Ub3ApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICByZWN0OiB0b3BSZWN0XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChib3R0b21SZWN0Rml0c09uQm90dG9tKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogZmxpcEhvcml6b250YWwocG9zaXRpb24pLFxuICAgICAgICByZWN0OiBib3R0b21SZWN0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwb3NpdGlvbklzQWxpZ25lZE9uVG9wKSB7XG4gICAgaWYgKGJvdHRvbVJlY3RGaXRzT25Cb3R0b20pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICByZWN0OiBib3R0b21SZWN0XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b3BSZWN0Rml0c09uVG9wKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogZmxpcEhvcml6b250YWwocG9zaXRpb24pLFxuICAgICAgICByZWN0OiB0b3BSZWN0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBtb3N0IHNwYWNpb3VzIGlmIHRoZXJlIGlzIG5vIGZpdC5cbiAgY29uc3Qgc3BhY2VCb3R0b20gPSBNYXRoLmFicyhcbiAgICB2aWV3cG9ydC5oZWlnaHQgLSB2aWV3cG9ydE9mZnNldCAtIGJvdHRvbVJlY3QuYm90dG9tXG4gIClcblxuICBjb25zdCBzcGFjZVRvcCA9IE1hdGguYWJzKHRvcFJlY3QudG9wIC0gdmlld3BvcnRPZmZzZXQpXG5cbiAgaWYgKHNwYWNlQm90dG9tIDwgc3BhY2VUb3ApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uSXNBbGlnbmVkT25Ub3AgPyBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbikgOiBwb3NpdGlvbixcbiAgICAgIHJlY3Q6IGJvdHRvbVJlY3RcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbklzQWxpZ25lZE9uVG9wID8gcG9zaXRpb24gOiBmbGlwSG9yaXpvbnRhbChwb3NpdGlvbiksXG4gICAgcmVjdDogdG9wUmVjdFxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBudW1iZXJzIGFuZCBwb3NpdGlvbiBhbmQgZ2l2ZXMgdGhlIGZpbmFsIGNvb3Jkcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXRPZmZzZXQgLSBvZmZzZXQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMg4oCUIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwb3NpdGlvbmVyLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFJlY3Qg4oCUIHRoZSByZWN0IG9mIHRoZSB0YXJnZXQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0geyB4OiBOdW1iZXIsIHk6IE51bWJlciB9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY3QoeyBwb3NpdGlvbiwgdGFyZ2V0T2Zmc2V0LCBkaW1lbnNpb25zLCB0YXJnZXRSZWN0IH0pIHtcbiAgY29uc3QgbGVmdFJlY3QgPSB0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoIC8gMiAtIGRpbWVuc2lvbnMud2lkdGggLyAyXG4gIGNvbnN0IGFsaWduZWRUb3BZID0gdGFyZ2V0UmVjdC50b3AgLSBkaW1lbnNpb25zLmhlaWdodCAtIHRhcmdldE9mZnNldFxuICBjb25zdCBhbGlnbmVkQm90dG9tWSA9IHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0T2Zmc2V0XG4gIGNvbnN0IGFsaWduZWRSaWdodFggPSB0YXJnZXRSZWN0LnJpZ2h0IC0gZGltZW5zaW9ucy53aWR0aFxuICBjb25zdCBhbGlnbmVkTGVmdFJpZ2h0WSA9XG4gICAgdGFyZ2V0UmVjdC50b3AgKyB0YXJnZXRSZWN0LmhlaWdodCAvIDIgLSBkaW1lbnNpb25zLmhlaWdodCAvIDJcblxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSBQb3NpdGlvbi5MRUZUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0IC0gZGltZW5zaW9ucy53aWR0aCAtIHRhcmdldE9mZnNldCxcbiAgICAgICAgdG9wOiBhbGlnbmVkTGVmdFJpZ2h0WVxuICAgICAgfSlcbiAgICBjYXNlIFBvc2l0aW9uLlJJR0hUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldE9mZnNldCxcbiAgICAgICAgdG9wOiBhbGlnbmVkTGVmdFJpZ2h0WVxuICAgICAgfSlcbiAgICBjYXNlIFBvc2l0aW9uLlRPUDpcbiAgICAgIHJldHVybiBtYWtlUmVjdChkaW1lbnNpb25zLCB7XG4gICAgICAgIGxlZnQ6IGxlZnRSZWN0LFxuICAgICAgICB0b3A6IGFsaWduZWRUb3BZXG4gICAgICB9KVxuICAgIGNhc2UgUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICAgIHRvcDogYWxpZ25lZFRvcFlcbiAgICAgIH0pXG4gICAgY2FzZSBQb3NpdGlvbi5UT1BfUklHSFQ6XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiBhbGlnbmVkUmlnaHRYLFxuICAgICAgICB0b3A6IGFsaWduZWRUb3BZXG4gICAgICB9KVxuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSBQb3NpdGlvbi5CT1RUT006XG4gICAgICByZXR1cm4gbWFrZVJlY3QoZGltZW5zaW9ucywge1xuICAgICAgICBsZWZ0OiBsZWZ0UmVjdCxcbiAgICAgICAgdG9wOiBhbGlnbmVkQm90dG9tWVxuICAgICAgfSlcbiAgICBjYXNlIFBvc2l0aW9uLkJPVFRPTV9MRUZUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IGFsaWduZWRCb3R0b21ZXG4gICAgICB9KVxuICAgIGNhc2UgUG9zaXRpb24uQk9UVE9NX1JJR0hUOlxuICAgICAgcmV0dXJuIG1ha2VSZWN0KGRpbWVuc2lvbnMsIHtcbiAgICAgICAgbGVmdDogYWxpZ25lZFJpZ2h0WCxcbiAgICAgICAgdG9wOiBhbGlnbmVkQm90dG9tWVxuICAgICAgfSlcbiAgfVxufVxuIl19