import _extends from "@babel/runtime/helpers/esm/extends";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import VirtualList from 'react-tiny-virtual-list';
import debounce from 'lodash.debounce';
import { Pane } from '../../layers';

var TableVirtualBody =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(TableVirtualBody, _PureComponent);

  _createClass(TableVirtualBody, null, [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (props.height !== state.calculatedHeight) {
        return {
          isIntegerHeight: Number.isInteger(props.height)
        };
      } // Return null to indicate no change to state.


      return null;
    }
  }]);

  function TableVirtualBody(props) {
    var _this;

    _classCallCheck(this, TableVirtualBody);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableVirtualBody).call(this, props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      isIntegerHeight: false,
      calculatedHeight: 0
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "initializeHelpers", function () {
      _this.autoHeights = [];
      _this.autoHeightRefs = [];
      _this.averageAutoHeight = _this.props.defaultHeight;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "processAutoHeights", function () {
      var isUpdated = false; // This will determine the averageAutoHeight.

      var total = 0;
      var totalAmount = 0; // Loop through all of the refs that have height="auto".

      _this.autoHeightRefs.forEach(function (ref, index) {
        // If the height is already calculated, skip it,
        // but calculate the height for the total.
        if (_this.autoHeights[index]) {
          total += _this.autoHeights[index];
          totalAmount += 1;
          return;
        } // Make sure the ref has a child


        if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {
          var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.

          total += height;
          totalAmount += 1; // Cache the height.

          _this.autoHeights[index] = height; // Set the update flag to true.

          isUpdated = true;
        }
      }); // Save the average height.


      _this.averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.
      // Call forceUpdate to make sure the virtual list renders again.

      if (isUpdated) _this.forceUpdate();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onRef", function (ref) {
      _this.paneRef = ref;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onVirtualHelperRef", function (index, ref) {
      _this.autoHeightRefs[index] = ref;
      requestAnimationFrame(function () {
        _this.processAutoHeights();
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onResize", function () {
      _this.updateOnResize();
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "updateOnResize", function () {
      _this.initializeHelpers(); // Simply return when we now the height of the pane is fixed.


      if (_this.state.isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.

      if (_this.paneRef) {
        var calculatedHeight = _this.paneRef.offsetHeight;

        if (calculatedHeight > 0) {
          // Save the calculated height which is needed for the VirtualList.
          _this.setState({
            calculatedHeight: calculatedHeight
          }); // Prevent updateOnResize being called recursively when there is a valid height.


          return;
        }
      } // When height is still 0 (or paneRef is not valid) try recursively until success.


      requestAnimationFrame(function () {
        _this.updateOnResize();
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "getItemSize", function (children) {
      var _this$props = _this.props,
          allowAutoHeight = _this$props.allowAutoHeight,
          useAverageAutoHeightEstimation = _this$props.useAverageAutoHeightEstimation,
          defaultHeight = _this$props.defaultHeight; // Prefer to return a array of all heights.

      if (!allowAutoHeight) {
        return children.map(function (child) {
          if (!React.isValidElement(child)) return defaultHeight;
          var height = child.props.height;

          if (Number.isInteger(height)) {
            return height;
          }

          return defaultHeight;
        });
      } // If allowAutoHeight is true, return a function instead.


      var itemSizeFn = function itemSizeFn(index) {
        if (!React.isValidElement(children[index])) return defaultHeight;
        var height = children[index].props.height; // When the height is number simply, simply return it.

        if (Number.isInteger(height)) {
          return height;
        } // When allowAutoHeight is set and  the height is set to "auto"...


        if (allowAutoHeight && children[index].props.height === 'auto') {
          // ... and the height is calculated, return the calculated height.
          if (_this.autoHeights[index]) return _this.autoHeights[index]; // ... if the height is not yet calculated, return the averge

          if (useAverageAutoHeightEstimation) return _this.averageAutoHeight;
        } // Return the default height.


        return defaultHeight;
      };

      return itemSizeFn;
    });

    _this.initializeHelpers(); // Add a onResize.


    _this.onResize = debounce(_this.onResize, 200);
    return _this;
  }

  _createClass(TableVirtualBody, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Call this to initialize and set
      this.updateOnResize();
      window.addEventListener('resize', this.onResize, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          inputChildren = _this$props2.children,
          paneHeight = _this$props2.height,
          defaultHeight = _this$props2.defaultHeight,
          allowAutoHeight = _this$props2.allowAutoHeight,
          overscanCount = _this$props2.overscanCount,
          estimatedItemSize = _this$props2.estimatedItemSize,
          useAverageAutoHeightEstimation = _this$props2.useAverageAutoHeightEstimation,
          scrollToIndex = _this$props2.scrollToIndex,
          scrollOffset = _this$props2.scrollOffset,
          scrollToAlignment = _this$props2.scrollToAlignment,
          props = _objectWithoutProperties(_this$props2, ["children", "height", "defaultHeight", "allowAutoHeight", "overscanCount", "estimatedItemSize", "useAverageAutoHeightEstimation", "scrollToIndex", "scrollOffset", "scrollToAlignment"]); // Children always needs to be an array.


      var children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren);
      var itemSize = this.getItemSize(children); // VirtualList needs a fixed height.

      var _this$state = this.state,
          calculatedHeight = _this$state.calculatedHeight,
          isIntegerHeight = _this$state.isIntegerHeight;
      return React.createElement(Pane, _extends({
        "data-evergreen-table-body": true,
        innerRef: this.onRef,
        height: paneHeight,
        flex: "1",
        overflow: "hidden"
      }, props), React.createElement(VirtualList, {
        height: isIntegerHeight ? paneHeight : calculatedHeight,
        width: "100%",
        estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? this.averageAutoHeight : estimatedItemSize || null,
        itemSize: itemSize,
        overscanCount: overscanCount,
        itemCount: React.Children.count(children),
        scrollToIndex: scrollToIndex,
        scrollOffset: scrollOffset,
        scrollToAlignment: scrollToAlignment,
        renderItem: function renderItem(_ref) {
          var index = _ref.index,
              style = _ref.style;

          // If some children are strings by accident, support this gracefully.
          if (!React.isValidElement(children[index])) {
            if (typeof children[index] === 'string') {
              return React.createElement("div", {
                style: style
              }, children[index]);
            }

            return React.createElement("div", {
              style: style
            }, "\xA0");
          } // When allowing height="auto" for rows, and a auto height item is
          // rendered for the first time...


          if (allowAutoHeight && React.isValidElement(children[index]) && children[index].props.height === 'auto' && // ... and only when the height is not already been calculated.
          !_this2.autoHeights[index]) {
            // ... render the item in a helper div, the ref is used to calculate
            // the height of its children.
            return React.createElement("div", {
              ref: function ref(_ref2) {
                return _this2.onVirtualHelperRef(index, _ref2);
              },
              "data-virtual-index": index,
              style: _objectSpread({
                opacity: 0
              }, style)
            }, children[index]);
          } // When allowAutoHeight is false, or when the height is known.
          // Simply render the item.


          return React.cloneElement(children[index], {
            style: style
          });
        }
      }));
    }
  }]);

  return TableVirtualBody;
}(PureComponent);

TableVirtualBody.displayName = "TableVirtualBody";

_defineProperty(TableVirtualBody, "propTypes", _objectSpread({}, Pane.propTypes, {
  /**
   * Children needs to be an array of a single node.
   */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),

  /**
   * Default height of each row.
   * 48 is the default height of a TableRow.
   */
  defaultHeight: PropTypes.number,

  /**
   * When true, support `height="auto"` on children being rendered.
   * This is somewhat of an expirmental feature.
   */
  allowAutoHeight: PropTypes.bool,

  /**
   * The overscanCount property passed to react-tiny-virtual-list.
   */
  overscanCount: PropTypes.number.isRequired,

  /**
   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.
   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.
   */
  estimatedItemSize: PropTypes.number,

  /**
   * When allowAutoHeight is true and this prop is true, the estimated height
   * will be computed based on the average height of auto height rows.
   */
  useAverageAutoHeightEstimation: PropTypes.bool,

  /**
   * The scrollToIndex property passed to react-tiny-virtual-list
   */
  scrollToIndex: PropTypes.number,

  /**
   * The scrollOffset property passed to react-tiny-virtual-list
   */
  scrollOffset: PropTypes.number,

  /**
   * The scrollToAlignment property passed to react-tiny-virtual-list
   */
  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto'])
}));

_defineProperty(TableVirtualBody, "defaultProps", {
  defaultHeight: 48,
  allowAutoHeight: false,
  overscanCount: 5,
  useAverageAutoHeightEstimation: true
});

export { TableVirtualBody as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVWaXJ0dWFsQm9keS5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlB1cmVDb21wb25lbnQiLCJQcm9wVHlwZXMiLCJWaXJ0dWFsTGlzdCIsImRlYm91bmNlIiwiUGFuZSIsIlRhYmxlVmlydHVhbEJvZHkiLCJwcm9wcyIsInN0YXRlIiwiaGVpZ2h0IiwiY2FsY3VsYXRlZEhlaWdodCIsImlzSW50ZWdlckhlaWdodCIsIk51bWJlciIsImlzSW50ZWdlciIsImF1dG9IZWlnaHRzIiwiYXV0b0hlaWdodFJlZnMiLCJhdmVyYWdlQXV0b0hlaWdodCIsImRlZmF1bHRIZWlnaHQiLCJpc1VwZGF0ZWQiLCJ0b3RhbCIsInRvdGFsQW1vdW50IiwiZm9yRWFjaCIsInJlZiIsImluZGV4IiwiY2hpbGROb2RlcyIsIm9mZnNldEhlaWdodCIsImZvcmNlVXBkYXRlIiwicGFuZVJlZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInByb2Nlc3NBdXRvSGVpZ2h0cyIsInVwZGF0ZU9uUmVzaXplIiwiaW5pdGlhbGl6ZUhlbHBlcnMiLCJzZXRTdGF0ZSIsImNoaWxkcmVuIiwiYWxsb3dBdXRvSGVpZ2h0IiwidXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uIiwibWFwIiwiY2hpbGQiLCJpc1ZhbGlkRWxlbWVudCIsIml0ZW1TaXplRm4iLCJvblJlc2l6ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5wdXRDaGlsZHJlbiIsInBhbmVIZWlnaHQiLCJvdmVyc2NhbkNvdW50IiwiZXN0aW1hdGVkSXRlbVNpemUiLCJzY3JvbGxUb0luZGV4Iiwic2Nyb2xsT2Zmc2V0Iiwic2Nyb2xsVG9BbGlnbm1lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJpdGVtU2l6ZSIsImdldEl0ZW1TaXplIiwib25SZWYiLCJjb3VudCIsInN0eWxlIiwib25WaXJ0dWFsSGVscGVyUmVmIiwib3BhY2l0eSIsImNsb25lRWxlbWVudCIsInByb3BUeXBlcyIsIm9uZU9mVHlwZSIsImFycmF5T2YiLCJub2RlIiwibnVtYmVyIiwiYm9vbCIsImlzUmVxdWlyZWQiLCJvbmVPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLGFBQWhCLFFBQXFDLE9BQXJDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLFdBQVAsTUFBd0IseUJBQXhCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixpQkFBckI7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGNBQXJCOztJQUVxQkMsZ0I7Ozs7Ozs7NkNBc0VhQyxLLEVBQU9DLEssRUFBTztBQUM1QyxVQUFJRCxLQUFLLENBQUNFLE1BQU4sS0FBaUJELEtBQUssQ0FBQ0UsZ0JBQTNCLEVBQTZDO0FBQzNDLGVBQU87QUFDTEMsVUFBQUEsZUFBZSxFQUFFQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJOLEtBQUssQ0FBQ0UsTUFBdkI7QUFEWixTQUFQO0FBR0QsT0FMMkMsQ0FPNUM7OztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7QUFFRCw0QkFBWUYsS0FBWixFQUFtQjtBQUFBOztBQUFBOztBQUNqQiwwRkFBTUEsS0FBTjs7QUFEaUIsb0ZBaEJYO0FBQ05JLE1BQUFBLGVBQWUsRUFBRSxLQURYO0FBRU5ELE1BQUFBLGdCQUFnQixFQUFFO0FBRlosS0FnQlc7O0FBQUEsZ0dBbUJDLFlBQU07QUFDeEIsWUFBS0ksV0FBTCxHQUFtQixFQUFuQjtBQUNBLFlBQUtDLGNBQUwsR0FBc0IsRUFBdEI7QUFDQSxZQUFLQyxpQkFBTCxHQUF5QixNQUFLVCxLQUFMLENBQVdVLGFBQXBDO0FBQ0QsS0F2QmtCOztBQUFBLGlHQTZCRSxZQUFNO0FBQ3pCLFVBQUlDLFNBQVMsR0FBRyxLQUFoQixDQUR5QixDQUd6Qjs7QUFDQSxVQUFJQyxLQUFLLEdBQUcsQ0FBWjtBQUNBLFVBQUlDLFdBQVcsR0FBRyxDQUFsQixDQUx5QixDQU96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QUUxQzs7O0FBR0FwQixFQUFBQSxhQUFhLEVBQUU5QyxTQUFTLENBQUNpRSxNOztBQUN6Qjs7O0FBR0FsQixFQUFBQSxZQUFZLEVBQUUvQyxTQUFTLENBQUNpRSxNOztBQUN4Qjs7O0FBR0FqQixFQUFBQSxpQkFBaUIsRUFBRWhELFNBQVMsQ0FBQ29FLEtBQVYsQ0FBZ0IsQ0FBQyxPQUFELEVBQVUsUUFBVixFQUFvQixLQUFwQixFQUEyQixNQUEzQixDQUFoQjs7O2dCQXZERmhFLGdCLGtCQTBERztBQUNwQlcsRUFBQUEsYUFBYSxFQUFFLEVBREs7QUFFcEJpQixFQUFBQSxlQUFlLEVBQUUsS0FGRztBQUdwQlksRUFBQUEsYUFBYSxFQUFFLENBSEs7QUFJcEJYLEVBQUFBLDhCQUE4QixFQUFFO0FBSlosQzs7U0ExREg3QixnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgVmlydHVhbExpc3QgZnJvbSAncmVhY3QtdGlueS12aXJ0dWFsLWxpc3QnXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJ1xuaW1wb3J0IHsgUGFuZSB9IGZyb20gJy4uLy4uL2xheWVycydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFibGVWaXJ0dWFsQm9keSBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBQYW5lIGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICAgKi9cbiAgICAuLi5QYW5lLnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIENoaWxkcmVuIG5lZWRzIHRvIGJlIGFuIGFycmF5IG9mIGEgc2luZ2xlIG5vZGUuXG4gICAgICovXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLFxuICAgICAgUHJvcFR5cGVzLm5vZGVcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaGVpZ2h0IG9mIGVhY2ggcm93LlxuICAgICAqIDQ4IGlzIHRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIFRhYmxlUm93LlxuICAgICAqL1xuICAgIGRlZmF1bHRIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHN1cHBvcnQgYGhlaWdodD1cImF1dG9cImAgb24gY2hpbGRyZW4gYmVpbmcgcmVuZGVyZWQuXG4gICAgICogVGhpcyBpcyBzb21ld2hhdCBvZiBhbiBleHBpcm1lbnRhbCBmZWF0dXJlLlxuICAgICAqL1xuICAgIGFsbG93QXV0b0hlaWdodDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3ZlcnNjYW5Db3VudCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3QuXG4gICAgICovXG4gICAgb3ZlcnNjYW5Db3VudDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBwYXNzZWQsIHRoaXMgaXMgdXNlZCBhcyB0aGUgYGVzdGltYXRlZEl0ZW1TaXplYCBpbiByZWFjdC10aW55LXZpcnR1YWwtbGlzdC5cbiAgICAgKiBPbmx5IHdoZW4gYGFsbG93QXV0b0hlaWdodGAgYW5kYHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbmAgYXJlIGZhbHNlLlxuICAgICAqL1xuICAgIGVzdGltYXRlZEl0ZW1TaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBhbGxvd0F1dG9IZWlnaHQgaXMgdHJ1ZSBhbmQgdGhpcyBwcm9wIGlzIHRydWUsIHRoZSBlc3RpbWF0ZWQgaGVpZ2h0XG4gICAgICogd2lsbCBiZSBjb21wdXRlZCBiYXNlZCBvbiB0aGUgYXZlcmFnZSBoZWlnaHQgb2YgYXV0byBoZWlnaHQgcm93cy5cbiAgICAgKi9cbiAgICB1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb246IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNjcm9sbFRvSW5kZXggcHJvcGVydHkgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAgICovXG4gICAgc2Nyb2xsVG9JbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAvKipcbiAgICAgKiBUaGUgc2Nyb2xsT2Zmc2V0IHByb3BlcnR5IHBhc3NlZCB0byByZWFjdC10aW55LXZpcnR1YWwtbGlzdFxuICAgICAqL1xuICAgIHNjcm9sbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAvKipcbiAgICAgKiBUaGUgc2Nyb2xsVG9BbGlnbm1lbnQgcHJvcGVydHkgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAgICovXG4gICAgc2Nyb2xsVG9BbGlnbm1lbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2NlbnRlcicsICdlbmQnLCAnYXV0byddKVxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkZWZhdWx0SGVpZ2h0OiA0OCxcbiAgICBhbGxvd0F1dG9IZWlnaHQ6IGZhbHNlLFxuICAgIG92ZXJzY2FuQ291bnQ6IDUsXG4gICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uOiB0cnVlXG4gIH1cblxuICBzdGF0ZSA9IHtcbiAgICBpc0ludGVnZXJIZWlnaHQ6IGZhbHNlLFxuICAgIGNhbGN1bGF0ZWRIZWlnaHQ6IDBcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmhlaWdodCAhPT0gc3RhdGUuY2FsY3VsYXRlZEhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbnRlZ2VySGVpZ2h0OiBOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmhlaWdodClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLmluaXRpYWxpemVIZWxwZXJzKClcblxuICAgIC8vIEFkZCBhIG9uUmVzaXplLlxuICAgIHRoaXMub25SZXNpemUgPSBkZWJvdW5jZSh0aGlzLm9uUmVzaXplLCAyMDApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBDYWxsIHRoaXMgdG8gaW5pdGlhbGl6ZSBhbmQgc2V0XG4gICAgdGhpcy51cGRhdGVPblJlc2l6ZSgpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUsIGZhbHNlKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpXG4gIH1cblxuICBpbml0aWFsaXplSGVscGVycyA9ICgpID0+IHtcbiAgICB0aGlzLmF1dG9IZWlnaHRzID0gW11cbiAgICB0aGlzLmF1dG9IZWlnaHRSZWZzID0gW11cbiAgICB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0ID0gdGhpcy5wcm9wcy5kZWZhdWx0SGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHByb2Nlc3MgYWxsIGl0ZW1zIHRoYXQgaGF2ZSBoZWlnaHQ9XCJhdXRvXCIgc2V0LlxuICAgKiBJdCB3aWxsIGxvb3AgdGhyb3VnaCBhbGwgcmVmcyBhbmQgZ2V0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0LlxuICAgKi9cbiAgcHJvY2Vzc0F1dG9IZWlnaHRzID0gKCkgPT4ge1xuICAgIGxldCBpc1VwZGF0ZWQgPSBmYWxzZVxuXG4gICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgYXZlcmFnZUF1dG9IZWlnaHQuXG4gICAgbGV0IHRvdGFsID0gMFxuICAgIGxldCB0b3RhbEFtb3VudCA9IDBcblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIHJlZnMgdGhhdCBoYXZlIGhlaWdodD1cImF1dG9cIi5cbiAgICB0aGlzLmF1dG9IZWlnaHRSZWZzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBoZWlnaHQgaXMgYWxyZWFkeSBjYWxjdWxhdGVkLCBza2lwIGl0LFxuICAgICAgLy8gYnV0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciB0aGUgdG90YWwuXG4gICAgICBpZiAodGhpcy5hdXRvSGVpZ2h0c1tpbmRleF0pIHtcbiAgICAgICAgdG90YWwgKz0gdGhpcy5hdXRvSGVpZ2h0c1tpbmRleF1cbiAgICAgICAgdG90YWxBbW91bnQgKz0gMVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWYgaGFzIGEgY2hpbGRcbiAgICAgIGlmIChcbiAgICAgICAgcmVmICYmXG4gICAgICAgIHJlZi5jaGlsZE5vZGVzICYmXG4gICAgICAgIHJlZi5jaGlsZE5vZGVzWzBdICYmXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIocmVmLmNoaWxkTm9kZXNbMF0ub2Zmc2V0SGVpZ2h0KVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHJlZi5jaGlsZE5vZGVzWzBdLm9mZnNldEhlaWdodFxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgdG90YWwgdG8gY2FsY3VsYXRlIHRoZSBhdmVyYWdlQXV0b0hlaWdodC5cbiAgICAgICAgdG90YWwgKz0gaGVpZ2h0XG4gICAgICAgIHRvdGFsQW1vdW50ICs9IDFcblxuICAgICAgICAvLyBDYWNoZSB0aGUgaGVpZ2h0LlxuICAgICAgICB0aGlzLmF1dG9IZWlnaHRzW2luZGV4XSA9IGhlaWdodFxuXG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZsYWcgdG8gdHJ1ZS5cbiAgICAgICAgaXNVcGRhdGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBTYXZlIHRoZSBhdmVyYWdlIGhlaWdodC5cbiAgICB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0ID0gdG90YWwgLyB0b3RhbEFtb3VudFxuXG4gICAgLy8gVGhlcmUgYXJlIHNvbWUgbmV3IGhlaWdodHMgZGV0ZWN0ZWQgdGhhdCBoYWQgcHJldmlvdXNseSBub3QgYmVlbiBjYWxjdWxhdGVkLlxuICAgIC8vIENhbGwgZm9yY2VVcGRhdGUgdG8gbWFrZSBzdXJlIHRoZSB2aXJ0dWFsIGxpc3QgcmVuZGVycyBhZ2Fpbi5cbiAgICBpZiAoaXNVcGRhdGVkKSB0aGlzLmZvcmNlVXBkYXRlKClcbiAgfVxuXG4gIG9uUmVmID0gcmVmID0+IHtcbiAgICB0aGlzLnBhbmVSZWYgPSByZWZcbiAgfVxuXG4gIG9uVmlydHVhbEhlbHBlclJlZiA9IChpbmRleCwgcmVmKSA9PiB7XG4gICAgdGhpcy5hdXRvSGVpZ2h0UmVmc1tpbmRleF0gPSByZWZcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NBdXRvSGVpZ2h0cygpXG4gICAgfSlcbiAgfVxuXG4gIG9uUmVzaXplID0gKCkgPT4ge1xuICAgIHRoaXMudXBkYXRlT25SZXNpemUoKVxuICB9XG5cbiAgdXBkYXRlT25SZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy5pbml0aWFsaXplSGVscGVycygpXG5cbiAgICAvLyBTaW1wbHkgcmV0dXJuIHdoZW4gd2Ugbm93IHRoZSBoZWlnaHQgb2YgdGhlIHBhbmUgaXMgZml4ZWQuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNJbnRlZ2VySGVpZ2h0KSByZXR1cm5cblxuICAgIC8vIFJldHVybiBpZiB3ZSBhcmUgaW4gYSB3ZWlyZCBlZGdlIGNhc2UgaW4gd2hpY2ggdGhlIHJlZiBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgaWYgKHRoaXMucGFuZVJlZikge1xuICAgICAgY29uc3QgY2FsY3VsYXRlZEhlaWdodCA9IHRoaXMucGFuZVJlZi5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGNhbGN1bGF0ZWRIZWlnaHQgPiAwKSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IHdoaWNoIGlzIG5lZWRlZCBmb3IgdGhlIFZpcnR1YWxMaXN0LlxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGVPblJlc2l6ZSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkgd2hlbiB0aGVyZSBpcyBhIHZhbGlkIGhlaWdodC5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBoZWlnaHQgaXMgc3RpbGwgMCAob3IgcGFuZVJlZiBpcyBub3QgdmFsaWQpIHRyeSByZWN1cnNpdmVseSB1bnRpbCBzdWNjZXNzLlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZU9uUmVzaXplKClcbiAgICB9KVxuICB9XG5cbiAgZ2V0SXRlbVNpemUgPSBjaGlsZHJlbiA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dBdXRvSGVpZ2h0LFxuICAgICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uLFxuICAgICAgZGVmYXVsdEhlaWdodFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICAvLyBQcmVmZXIgdG8gcmV0dXJuIGEgYXJyYXkgb2YgYWxsIGhlaWdodHMuXG4gICAgaWYgKCFhbGxvd0F1dG9IZWlnaHQpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGRlZmF1bHRIZWlnaHRcbiAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNoaWxkLnByb3BzXG5cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiBoZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIGFsbG93QXV0b0hlaWdodCBpcyB0cnVlLCByZXR1cm4gYSBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgIGNvbnN0IGl0ZW1TaXplRm4gPSBpbmRleCA9PiB7XG4gICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuW2luZGV4XSkpIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICBjb25zdCB7IGhlaWdodCB9ID0gY2hpbGRyZW5baW5kZXhdLnByb3BzXG5cbiAgICAgIC8vIFdoZW4gdGhlIGhlaWdodCBpcyBudW1iZXIgc2ltcGx5LCBzaW1wbHkgcmV0dXJuIGl0LlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHNldCBhbmQgIHRoZSBoZWlnaHQgaXMgc2V0IHRvIFwiYXV0b1wiLi4uXG4gICAgICBpZiAoYWxsb3dBdXRvSGVpZ2h0ICYmIGNoaWxkcmVuW2luZGV4XS5wcm9wcy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAvLyAuLi4gYW5kIHRoZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBjYWxjdWxhdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKHRoaXMuYXV0b0hlaWdodHNbaW5kZXhdKSByZXR1cm4gdGhpcy5hdXRvSGVpZ2h0c1tpbmRleF1cblxuICAgICAgICAvLyAuLi4gaWYgdGhlIGhlaWdodCBpcyBub3QgeWV0IGNhbGN1bGF0ZWQsIHJldHVybiB0aGUgYXZlcmdlXG4gICAgICAgIGlmICh1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb24pIHJldHVybiB0aGlzLmF2ZXJhZ2VBdXRvSGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgZGVmYXVsdCBoZWlnaHQuXG4gICAgICByZXR1cm4gZGVmYXVsdEhlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBpdGVtU2l6ZUZuXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW46IGlucHV0Q2hpbGRyZW4sXG4gICAgICBoZWlnaHQ6IHBhbmVIZWlnaHQsXG4gICAgICBkZWZhdWx0SGVpZ2h0LFxuICAgICAgYWxsb3dBdXRvSGVpZ2h0LFxuICAgICAgb3ZlcnNjYW5Db3VudCxcbiAgICAgIGVzdGltYXRlZEl0ZW1TaXplLFxuICAgICAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uLFxuICAgICAgc2Nyb2xsVG9JbmRleCxcbiAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgIHNjcm9sbFRvQWxpZ25tZW50LFxuICAgICAgLi4ucHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgLy8gQ2hpbGRyZW4gYWx3YXlzIG5lZWRzIHRvIGJlIGFuIGFycmF5LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShpbnB1dENoaWxkcmVuKVxuICAgICAgPyBpbnB1dENoaWxkcmVuXG4gICAgICA6IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoaW5wdXRDaGlsZHJlbilcblxuICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5nZXRJdGVtU2l6ZShjaGlsZHJlbilcblxuICAgIC8vIFZpcnR1YWxMaXN0IG5lZWRzIGEgZml4ZWQgaGVpZ2h0LlxuICAgIGNvbnN0IHsgY2FsY3VsYXRlZEhlaWdodCwgaXNJbnRlZ2VySGVpZ2h0IH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmVcbiAgICAgICAgZGF0YS1ldmVyZ3JlZW4tdGFibGUtYm9keVxuICAgICAgICBpbm5lclJlZj17dGhpcy5vblJlZn1cbiAgICAgICAgaGVpZ2h0PXtwYW5lSGVpZ2h0fVxuICAgICAgICBmbGV4PVwiMVwiXG4gICAgICAgIG92ZXJmbG93PVwiaGlkZGVuXCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgPlxuICAgICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgICBoZWlnaHQ9e2lzSW50ZWdlckhlaWdodCA/IHBhbmVIZWlnaHQgOiBjYWxjdWxhdGVkSGVpZ2h0fVxuICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgZXN0aW1hdGVkSXRlbVNpemU9e1xuICAgICAgICAgICAgYWxsb3dBdXRvSGVpZ2h0ICYmIHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvblxuICAgICAgICAgICAgICA/IHRoaXMuYXZlcmFnZUF1dG9IZWlnaHRcbiAgICAgICAgICAgICAgOiBlc3RpbWF0ZWRJdGVtU2l6ZSB8fCBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW1TaXplPXtpdGVtU2l6ZX1cbiAgICAgICAgICBvdmVyc2NhbkNvdW50PXtvdmVyc2NhbkNvdW50fVxuICAgICAgICAgIGl0ZW1Db3VudD17UmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pfVxuICAgICAgICAgIHNjcm9sbFRvSW5kZXg9e3Njcm9sbFRvSW5kZXh9XG4gICAgICAgICAgc2Nyb2xsT2Zmc2V0PXtzY3JvbGxPZmZzZXR9XG4gICAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9e3Njcm9sbFRvQWxpZ25tZW50fVxuICAgICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBzb21lIGNoaWxkcmVuIGFyZSBzdHJpbmdzIGJ5IGFjY2lkZW50LCBzdXBwb3J0IHRoaXMgZ3JhY2VmdWxseS5cbiAgICAgICAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW5baW5kZXhdKSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuW2luZGV4XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBzdHlsZT17c3R5bGV9PntjaGlsZHJlbltpbmRleF19PC9kaXY+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGU9e3N0eWxlfT4mbmJzcDs8L2Rpdj5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiBhbGxvd2luZyBoZWlnaHQ9XCJhdXRvXCIgZm9yIHJvd3MsIGFuZCBhIGF1dG8gaGVpZ2h0IGl0ZW0gaXNcbiAgICAgICAgICAgIC8vIHJlbmRlcmVkIGZvciB0aGUgZmlyc3QgdGltZS4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBhbGxvd0F1dG9IZWlnaHQgJiZcbiAgICAgICAgICAgICAgUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW5baW5kZXhdKSAmJlxuICAgICAgICAgICAgICBjaGlsZHJlbltpbmRleF0ucHJvcHMuaGVpZ2h0ID09PSAnYXV0bycgJiZcbiAgICAgICAgICAgICAgLy8gLi4uIGFuZCBvbmx5IHdoZW4gdGhlIGhlaWdodCBpcyBub3QgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgICF0aGlzLmF1dG9IZWlnaHRzW2luZGV4XVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIC4uLiByZW5kZXIgdGhlIGl0ZW0gaW4gYSBoZWxwZXIgZGl2LCB0aGUgcmVmIGlzIHVzZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIHJlZj17cmVmID0+IHRoaXMub25WaXJ0dWFsSGVscGVyUmVmKGluZGV4LCByZWYpfVxuICAgICAgICAgICAgICAgICAgZGF0YS12aXJ0dWFsLWluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0eWxlXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbltpbmRleF19XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiBhbGxvd0F1dG9IZWlnaHQgaXMgZmFsc2UsIG9yIHdoZW4gdGhlIGhlaWdodCBpcyBrbm93bi5cbiAgICAgICAgICAgIC8vIFNpbXBseSByZW5kZXIgdGhlIGl0ZW0uXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuW2luZGV4XSwge1xuICAgICAgICAgICAgICBzdHlsZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9QYW5lPlxuICAgIClcbiAgfVxufVxuIl19